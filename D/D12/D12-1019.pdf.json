{"sections":[{"title":"","paragraphs":["Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 205–213, Jeju Island, Korea, 12–14 July 2012. c⃝2012 Association for Computational Linguistics"]},{"title":"Spectral Dependency Parsing with Latent VariablesParamveer S. Dhillon","paragraphs":["1"]},{"title":", Jordan Rodu","paragraphs":["2"]},{"title":", Michael Collins","paragraphs":["3"]},{"title":", Dean P. Foster","paragraphs":["2"]},{"title":"and Lyle H. Ungar","paragraphs":["1 1"]},{"title":"Computer & Information Science/","paragraphs":["2"]},{"title":"Statistics, University of Pennsylvania, Philadelphia, PA, U.S.A","paragraphs":["3"]},{"title":"Computer Science, Columbia University, New York, NY, U.S.A{dhillon|ungar@cis.upenn.edu}, {jrodu|foster@wharton.upenn.edu}mcollins@cs.columbia.eduAbstract","paragraphs":["Recently there has been substantial interest in using spectral methods to learn generative sequence models like HMMs. Spectral methods are attractive as they provide globally consistent estimates of the model parameters and are very fast and scalable, unlike EM methods, which can get stuck in local minima. In this paper, we present a novel extension of this class of spectral methods to learn dependency tree structures. We propose a simple yet powerful latent variable generative model for dependency parsing, and a spectral learning method to efficiently estimate it. As a pilot experimental evaluation, we use the spectral tree probabilities estimated by our model to re-rank the outputs of a near state-of-the-art parser. Our approach gives us a moderate reduction in error of up to 4.6% over the baseline re-ranker."]},{"title":"1 Introduction","paragraphs":["Markov models have been for two decades a workhorse of statistical pattern recognition with applications ranging from speech to vision to language. Adding latent variables to these models gives us additional modeling power and have shown success in applications like POS tagging (Merialdo, 1994), speech recognition (Rabiner, 1989) and object recognition (Quattoni et al., 2004). However, this comes at the cost that the resulting parameter estimation problem becomes non-convex and techniques like EM (Dempster et al., 1977) which are used to estimate the parameters can only lead to locally optimal solutions.","Recent work by Hsu et al. (2008) has shown that globally consistent estimates of the parameters of HMMs can be found by using spectral methods, particularly by singular value decomposition (SVD) of appropriately defined linear systems. They avoid the NP Hard problem of the global optimization problem of the HMM parameters (Terwijn, 2002), by putting restrictions on the smallest singular value of the HMM parameters. The main intuition behind the model is that, although the observed data (i.e. words) seem to live in a very high dimensional space, but in reality they live in a very low dimensional space (size k ∼ 30 − 50) and an appropriate eigen decomposition of the observed data will reveal the underlying low dimensional dynamics and thereby revealing the parameters of the model. Besides ducking the NP hard problem, the spectral methods are very fast and scalable to train compared to EM methods.","In this paper we generalize the approach of Hsu et al. (2008) to learn dependency tree structures with latent variables.1","Petrov et al. (2006) and Musillo and Merlo (2008) have shown that learning PCFGs and dependency grammars respectively with latent variables can produce parsers with very good generalization performance. However, both these approaches rely on EM for parameter estimation and can benefit from using spectral methods.","We propose a simple yet powerful latent variable generative model for use with dependency pars-","1","Actually, instead of using the model by Hsu et al. (2008) we work with a related model proposed by Foster et al. (2012) which addresses some of the shortcomings of the earlier model which we detail below. 205 ing which has one hidden node for each word in the sentence, like the one shown in Figure 1 and work out the details for the parameter estimation of the corresponding spectral learning model. At a very high level, the parameter estimation of our model involves collecting unigram, bigram and trigram counts sensitive to the underlying dependency structure of the given sentence.","Recently, Luque et al. (2012) have also proposed a spectral method for dependency parsing, however they deal with horizontal markovization and use hidden states to model sequential dependencies within a word’s sequence of children. In contrast with that, in this paper, we propose a spectral learning algorithm where latent states are not restricted to HMM-like distributions of modifier sequences for a particular head, but instead allow information to be propagated through the entire tree.","More recently, Cohen et al. (2012) have proposed a spectral method for learning PCFGs.","Its worth noting that recent work by Parikh et al. (2011) also extends Hsu et al. (2008) to latent variable dependency trees like us but under the restrictive conditions that model parameters are trained for a specified, albeit arbitrary, tree topology.2","In other words, all training sentences and test sentences must have identical tree topologies. By doing this they allow for node-specific model parameters, but must re-train the model entirely when a different tree topology is encountered. Our model on the other hand allows the flexibility and efficiency of processing sentences with a variety of tree topologies from a single training run.","Most of the current state-of-the-art dependency parsers are discriminative parsers (Koo et al., 2008; McDonald, 2006) due to the flexibility of representations which can be used as features leading to better accuracies and the ease of reproducibility of results. However, unlike discriminative models, generative models can exploit unlabeled data. Also, as is common in statistical parsing, re-ranking the outputs of a parser leads to significant reductions in error (Collins and Koo, 2005).","Since our spectral learning algorithm uses a gen-","2","This can be useful in modeling phylogeny trees for instance, but precludes most NLP applications, since there is a need to model the full set of different tree topologies possible in parsing. h0 h1 h2 was Kilroy here Figure 1: Sample dependency parsing tree for “Kilroy was here” erative model of words given a tree structure, it can score a tree structure i.e. its probability of generation. Thus, it can be used to re-rank the n-best outputs of a given parser.","The remainder of the paper is organized as follows. In the next section we introduce the notation and give a brief overview of the spectral algorithm for learning HMMs (Hsu et al., 2008; Foster et al., 2012). In Section 3 we describe our proposed model for dependency parsing in detail and work out the theory behind it. Section 4 provides experimental evaluation of our model on Penn Treebank data. We conclude with a brief summary and future avenues for research."]},{"title":"2 Spectral Algorithm For Learning HMMs","paragraphs":["In this section we describe the spectral algorithm for learning HMMs.3 2.1 Notation The HMM that we consider in this section is a sequence of hidden states h ∈ {1, . . . , k} that follow the Markov property: p(ht|h1, . . . , ht−1) = p(ht|ht−1) and a sequence of observations x ∈ {1, . . . , n} such that","p(xt|x1, . . . , xt−1, h1, . . . , ht) = p(xt|ht)","3","As mentioned earlier, we use the model by Foster et al. (2012) which is conceptually similar to the one by Hsu et al. (2008), but does further dimensionality reduction and thus has lower sample complexity. Also, critically, the fully reduced dimension model that we use generalizes much more cleanly to trees. 206 The parameters of this HMM are:","• A vector π of length k where πi = p(h1 = i): The probability of the start state in the sequence being i.","• A matrix T of size k × k where Ti,j = p(ht+1 = i|ht = j): The probability of transitioning to state i, given that the previous state was j.","• A matrix O of size n × k where Oi,j = p(x = i|h = j): The probability of state h emitting observation x.","Define δj to be the vector of length n with a 1 in the jth","entry and 0 everywhere else, and diag(v) to be the matrix with the entries of v on the diagonal and 0 everywhere else.","The joint distribution of a sequence of observations x1, . . . , xm and a sequence of hidden states h1, . . . , hm is: p(x1, . . . ,xm, h1, . . . , hm) = πh1 m−1 ∏ j=2 Thj,hj−1 m ∏ j=1 Oxj,hj","Now, we can write the marginal probability of a sequence of observations as p(x1, . . . xm) = ∑ h1,...,hm p(x1, . . . , xm, h1, . . . , hm)","which can be expressed in matrix form4 as:","p(x1, . . . , xm) = 1⊤ AxmAxm−1 · · · Am1π where Axm","≡ T diag(O⊤","δxm), and 1 is a k-dimensional vector with every entry equal to 1.","A is called an “observation operator”, and is effectively a third order tensor, and Axm which is a matrix, gives the distribution vector over states at time m+1 as a function of the state distribution vector at the current time m and the current observation δxm. Since Axm depends on the hidden state, it is not observable, and hence cannot be directly estimated.","4","This is essentially the matrix form of the standard dynamic program (forward algorithm) used to estimate HMMs. However, Hsu et al. (2008) and Foster et al. (2012) showed that under certain conditions there exists a fully observable representation of the observable operator model. 2.2 Fully observable representation Before presenting the model, we need to address a few more points. First, let U be a “representation matrix” (eigenfeature dictionary) which maps each observation to a reduced dimension space (n → k) that satisfies the conditions:","• U ⊤ O is invertible • |Uij| < 1.","Hsu et al. (2008); Foster et al. (2012) discuss U in more detail, but U can, for example, be obtained by the SVD of the bigram probability matrix (where Pij = p(xt+1 = i|xt = j)) or by doing CCA on neighboring n-grams (Dhillon et al., 2011).","Letting yi = U ⊤","δxi, we have p(x1, . . . , xm)","= c⊤ ∞C(ym)C(ym−1) . . . C(y1)c1 (1) where c1 = μ c∞","= μ⊤ Σ−1 C(y) = K(y)Σ−1 and μ, Σ and K, described in more detail below, are quantities estimated by frequencies of unigrams, bigrams, and trigrams in the observed (training) data.","Under the assumption that data is generated by an HMM, the distribution p̂ obtained by substituting the estimated values ĉ1, ĉ∞, and ̂C(y) into equation (1) converges to p sufficiently fast as the amount of training data increases, giving us consistent parameter estimates. For details of the convergence proof, please see Hsu et al. (2008) and Foster et al. (2012)."]},{"title":"3 Spectral Algorithm For LearningDependency Trees","paragraphs":["In this section, we first describe a simple latent variable generative model for dependency parsing. We then define some extra notation and finally present 207 the details of the corresponding spectral learning algorithm for dependency parsing, and prove that our learning algorithm provides a consistent estimation of the marginal probabilities.","It is worth mentioning that an alternate way of approaching the spectral estimation of latent states for dependency parsing is by converting the dependency trees into linear sequences from root-to-leaf and doing a spectral estimation of latent states using Hsu et al. (2008). However, this approach would not give us the correct probability distribution over trees as the probability calculations for different paths through the trees are not independent. Thus, although one could calculate the probability of a path from the root to a leaf, one cannot generalize from this probability to say anything about the neighboring nodes or words. Put another way, when a parent has more than the one descendant, one has to be careful to take into account that the hidden variables at each child node are all conditioned on the hidden variable of the parent. 3.1 A latent variable generative model for dependency parsing In the standard setting, we are given training examples where each training example consists of a sequence of words x1, . . . , xm together with a dependency structure over those words, and we want to estimate the probability of the observed structure. This marginal probability estimates can then be used to build an actual generative dependency parser or, since the marginal probability is conditioned on the tree structure, it can be used re-rank the outputs of a parser.","As in the conventional HMM described in the previous section, we can define a simple latent variable first order dependency parsing model by introduc-ing a hidden variable hi for each word xi. The joint probability of a sequence of observed nodes x1, . . . , xm together with hidden nodes h1, . . . , hm can be written as p(x1, . . . ,xm, h1, . . . , hm) = πh1 m ∏ j=2 td(j)(hj|hpa(j)) m ∏ j=1 o(xj|hj) (2) h1 h2 h3 y1 y2 y3 Figure 2: Dependency parsing tree with observed variables y1, y2, and y3. where pa(j) is the parent of node j and d(j) ∈ {L, R} indicates whether hj is a left or a right node of hpa(j). For simplicity, the number of hidden and observed nodes in our tree are the same, however they are not required to be so.","As is the case with the conventional HMM, the parameters used to calculate this joint probability are unobservable, but it turns out that under suitable conditions a fully observable model is also possible for the dependency tree case with the parameterization as described below. 3.2 Model parameters We will define both the theoretical representations of our observable parameters, and the sampling versions of these parameters. Note that in all the cases, the estimated versions are unbiased estimates of the theoretical quantities.","Define Td and T u","d where d ∈ {L, R} to be the hidden state transition matrices from parent to left or right child, and from left or right child to parent (hence the u for ‘up’), respectively. In other words (referring to Figure 2) TR = t(h3|h1) TL = t(h2|h1) T u R = t(h1|h3) T u L = t(h1|h2) Let Ux(i) be the ith","entry of vector U ⊤","δx and G =","U ⊤ O. Further, recall the notation diag(v), which is","a matrix with elements of v on its diagonal, then: • Define the k-dimensional vector μ (unigram 208 counts): μ = Gπ [μ̂]i = n ∑ u=1 c̄(u)Uu(i) where c̄(u) = c(u)","N1 , c(u) is the count of observation u in the training sample, and N1 =∑ u∈n c(u).","• Define the k×k matrices ΣL and ΣR (left child-parent and right child-parent bigram counts):","[ Σ̂L]i,j = n ∑ u=1 n","∑","v=1 c̄L(u, v)Uu(j)Uv(i)","ΣL = GT u L diag(π)G⊤","[ Σ̂R]i,j = n ∑ u=1 n","∑","v=1 c̄R(u, v)Uu(j)Uv(i)","ΣR = GT u Rdiag(π)G⊤ where c̄L(u, v) = cL(u,v)","N2","L , cL(u, v) is the count of bigram (u, v) where u is the left child and v is the parent in the training sample, and N2L = ∑","(u,v)∈n×n cL(u, v). Define c̄R(u, v) similarly.","• Define k × k × k tensor K (left child-parent-right child trigram counts):","K̂i,j,l = n","∑","u=1 n ∑ v=1 n","∑","w=1 c̄(u, v, w)Uw(i)Uu(j)Uv(l)","K(y) = GTLdiag(G⊤ y)T u","Rdiag(π)G⊤ where c̄(w, u, v) =","c(w,u,v) N3 , c(w, u, v) is the count of bigram (w, u, v) where w is the left child, u is the parent and v is the right child in the training sample, and N3 =∑","(w,u,v)∈n×n×n c(w, u, v).","• Define k × k matrices ΩL and ΩR (skip-bigram counts (left child-right child) and (right child-","left child)) 5 :","[ Ω̂L]i,j = n","∑","u=1 n ∑ v=1 n","∑","w=1 c̄(u, v, w)Uw(i)Uu(j)","ΩL = GTLT u Rdiag(π)G⊤","[ Ω̂R]i,j = n","∑","u=1 n ∑ v=1 n","∑","w=1 c̄(u, v, w)Uw(j)Uu(i)","ΩR = GTRT u L diag(π)G⊤ 3.3 Parameter estimation Using the above definitions, we can estimate the parameters of the model, namely μ, ΣL, ΣR, ΩL, ΩR and K, from the training data and define observables useful for the dependency model as6 c1 = μ","cT","∞ = μT","Σ−1","R","EL = ΩLΣ−1 R","ER = ΩRΣ−1 L","D(y) = E−1 L K(y)Σ−1","R As we will see, these quantities allow us to recursively compute the marginal probability of the dependency tree, p̂(x1, . . . , xm), in a bottom up manner by using belief propagation.","To see this, let hch(i) be the set of hidden children of hidden node i (in Figure 2 for instance, hch(1) = {2, 3}) and let och(i) be the set of observed children of hidden node i (in the same figure och(i) = {1}). Then compute the marginal probability p(x1, . . . , xm) from Equation 2 as ri(h) = ∏ j∈hch(i) αj(h) ∏ j∈och(i) o(xj|h) (3)","where αi(h) is defined by summing over all","the hidden random variables i.e., αi(h) =∑ h′ p(h′","|h)ri(h′","). This can be written in a compact matrix form as","−→ri ⊤ = 1⊤ ∏","j∈hch(i) diag(T ⊤ dj −→rj ) · ∏","j∈och(i) diag(O⊤ δxj ) (4) 5 Note than ΩR = ΩT","L, which is not immediately obvious","from the matrix representations. 6 The details of the derivation follow directly from the matrix","versions of the variables. 209 where −→ri is a vector of size k (the dimensionality of the hidden space) of values ri(h). Note that since in Equation 2 we condition on whether xj is the left or right child of its parent, we have separate transition matrices for left and right transitions from a given hidden node dj ∈ {L, R}.","The recursive computation can be written in terms of observables as:","−→ri ⊤ = c⊤","∞ ∏","j∈hch(i) D(E⊤ dj −→rj ) · ∏","j∈och(i) D((U ⊤","U )−1","U ⊤","δxj )","The final calculation for the marginal probability of a given sequence is","p̂(x1, . . . , xm) = −→r1 ⊤ c1 (5)","The spectral estimation procedure is described be-low in Algorithm 1.","Algorithm 1 Spectral dependency parsing (Comput-","ing marginal probability of a tree.)","1: Input: Training examples- x(i)","for i ∈ {1, . . . , M } along with dependency structures where each sequence x(i)","= x(i)","1 , . . . , x(i)","mi.","2: Compute the spectral parameters μ̂, Σ̂R, Σ̂L, Ω̂R, Ω̂L, and K̂ #Now, for a given sentence, we can recursively compute the following:","3: for x(i)","j for j ∈ {mi, . . . , 1} do","4: Compute:","−→ri ⊤ = c⊤","∞ ∏","j∈hch(i) D(E⊤ dj −→rj ) · ∏","j∈och(i) D((U ⊤","U )−1","U ⊤","δxj ) 5: end for 6: Finally compute","p̂(x1, . . . , xmi) = −→r1⊤ c1 #The marginal probability of an entire tree. 3.4 Sample complexity Our main theoretical result states that the above scheme for spectral estimation of marginal probabilities provides a guaranteed consistent estimation scheme for the marginal probabilities: Theorem 3.1. Let the sequence {x1, . . . , xm} be generated by an k ≥ 2 state HMM. Suppose we are given a U which has the property that U ⊤","O is invertible, and |Uij| ≤ 1. Suppose we use equation (5) to estimate the probability based on N independent triples. Then N","≥ Cm k2","ε2 log (","k","δ ) (6) where Cm is specified in the appendix, implies that","1 − ε ≤ ∣ ∣ ∣ ∣ ̂p(x1, . . . , xm) p(x1, . . . , xm) ∣","∣","∣","∣ ≤ 1 + ε holds with probability at least 1 − δ. Proof. A sketch of the proof, in the case without directional transition parameters, can be found in the appendix. The proof with directional transition parameters is almost identical."]},{"title":"4 Experimental Evaluation","paragraphs":["Since our algorithm can score any given tree structure by computing its marginal probability, a natural way to benchmark our parser is to generate n-best dependency trees using some standard parser and then use our algorithm to re-rank the candidate dependency trees, e.g. using the log spectral probability as described in Algorithm 1 as a feature in a discriminative re-ranker. 4.1 Experimental Setup Our base parser was the discriminatively trained MSTParser (McDonald, 2006), which implements both first and second order parsers and is trained using MIRA (Crammer et al., 2006) and used the standard baseline features as described in McDonald (2006).","We tested our methods on the English Penn Treebank (Marcus et al., 1993). We use the standard splits of Penn Treebank; i.e., we used sections 2-21 for training, section 22 for development and section 23 for testing. We used the PennConverter7","tool to convert Penn Treebank from constituent to dependency format. Following (McDonald, 2006; Koo","7","http://nlp.cs.lth.se/software/treebank_ converter/ 210 et al., 2008), we used the POS tagger by Ratnaparkhi (1996) trained on the full training data to provide POS tags for development and test sets and used 10-way jackknifing to generate tags for the training set. As is common practice we stripped our sentences of all the punctuation. We evaluated our approach on sentences of all lengths. 4.2 Details of spectral learning For the spectral learning phase, we need to just collect word counts from the training data as described above, so there are no tunable parameters as such. However, we need to have access to an attribute dictionary U which contains a k dimensional representation for each word in the corpus. A possible way of generating U as suggested by Hsu et al. (2008) is by performing SVD on bigrams P21 and using the left eigenvectors as U . We instead used the eigen-feature dictionary proposed by Dhillon et al. (2011) (LR-MVL) which is obtained by performing CCA on neighboring words and has provably better sample complexity for rare words compared to the SVD alternative.","We induced the LR-MVL embeddings for words using the Reuters RCV1 corpus which contains about 63 million tokens in 3.3 million sentences and used their context oblivious embeddings as our estimate of U . We experimented with different choices of k (the size of the low dimensional projection) on the development set and found k = 10 to work reasonably well and fast. Using k = 10 we were able to estimate our spectral learning parameters μ, ΣL,R, ΩL,R, K from the entire training data in under 2 minutes on a 64 bit Intel 2.4 Ghz processor. 4.3 Re-ranking the outputs of MST parser We could not find any previous work which describes features for discriminative re-ranking for dependency parsing, which is due to the fact that unlike constituency parsing, the base parsers for dependency parsing are discriminative (e.g. MST parser) which obviates the need for re-ranking as one could add a variety of features to the baseline parser itself. However, parse re-ranking is a good testbed for our spectral dependency parser which can score a given tree. So, we came up with a baseline set of features to use in an averaged perceptron re-ranker (Collins, 2002). Our baseline features comprised of two main Method Accuracy Complete I Order MST Parser (No RR) 90.8 37.2 RR w. Base. Features 91.3 37.5 RR w. Base. Features +log p̂ 91.7 37.8 II Order MST Parser (No RR) 91.8 40.6 RR w. Base. Features 92.4 41.0 RR w. Base. Features +log p̂ 92.7 41.3 Table 1: (Unlabeled) Dependency Parse re-ranking results for English test set (Section 23). Note: 1). RR = Re-ranking 2). Accuracy is the number of words which correctly identified their parent and Complete is the number of sentences for which the entire dependency tree was correct. 3). Base. Features are the two re-ranking features described in Section 4.3. 4). log p̂ is the spectral log probability feature. features which capture information that varies across the different n-best parses and moreover were not used as features by the baseline MST parser, ⟨POS-left-modifier ∧ POS-head ∧ POS-right-modifier⟩ and ⟨POS-left/right-modifier ∧ POS-head ∧ POS-grandparent⟩8",". In addition to that we used the log of spectral probability (p̂(x1, . . . , xm) - as calculated using Algorithm 1) as a feature.","We used the MST parser trained on entire training data to generate a list of n-best parses for the development and test sets. The n-best parses for the training set were generated by 3-fold cross validation, where we train on 2 folds to get the parses for the third fold. In all our experiments we used n = 50. The results are shown in Table 1. As can be seen, the best results give up to 4.6% reduction in error over the re-ranker which uses just the baseline set of features."]},{"title":"5 Discussion and Future Work","paragraphs":["Spectral learning of structured latent variable models in general is a promising direction as has been shown by the recent interest in this area. It allows us to circumvent the ubiquitous problem of get-ting stuck in local minima when estimating the latent variable models via EM. In this paper we ex-","8","One might be able to come up with better features for dependency parse re-ranking. Our goal in this paper was just to get a reasonable baseline. 211 tended the spectral learning ideas to learn a simple yet powerful dependency parser. As future work, we are working on building an end-to-end parser which would involve coming up with a spectral version of the inside-outside algorithm for our setting. We are also working on extending it to learn more powerful grammars e.g. split head-automata grammars (SHAG) (Eisner and Satta, 1999)."]},{"title":"6 Conclusion","paragraphs":["In this paper we proposed a novel spectral method for dependency parsing. Unlike EM trained generative latent variable models, our method does not get stuck in local optima, it gives consistent parameter estimates, and it is extremely fast to train. We worked out the theory of a simple yet powerful generative model and showed how it can be learned using a spectral method. As a pilot experimental evaluation we showed the efficacy of our approach by using the spectral probabilities output by our model for re-ranking the outputs of MST parser. Our method reduced the error of the baseline re-ranker by up to a moderate 4.6%."]},{"title":"7 Appendix","paragraphs":["This appendix offers a sketch of the proof of Theorem 1. The proof uses the following definitions, which are slightly modified from those of Foster et al. (2012).","Definition 1. Define Λ as the smallest element of μ,","Σ−1",", Ω−1",", and K(). In other words,","Λ ≡ min{min","i |μi|, min","i,j |Σ−1","ij |, min","i,j |Ω−1","ij |,","min","i,j,k |Kijk|, min","i,j |Σij|, min","i,j |Ωij|, } where Kijk = K(δj)ik are the elements of the tensor K(). Definition 2. Define σk as the smallest singular value of Σ and Ω.","The proof relies on the fact that a row vector multiplied by a series of matrices, and finally multiplied by a column vector amounts to a sum over all possible products of individual entries in the vectors and matrices. With this in mind, if we bound the largest relative error of any particular entry in the matrix by, say, ω, and there are, say, s parameters (vectors and matrices) being multiplied together, then by simple algebra the total relative error of the sum over the products is bounded by ωs",".","The proof then follows from two basic steps. First, one must bound the maximal relative error, ω for any particular entry in the parameters, which can be done using central limit-type theorems and the quantity Λ described above. Then, to calculate the exponent s one simply counts the number of parameters multiplied together when calculating the probability of a particular sequence of observations.","Since each hidden node is associated with exactly one observed node, it follows that s = 12m + 2L, where L is the number of levels (for instance in our example “Kilroy was here” there are two levels). s can be easily computed for arbitrary tree topologies.","It follows from Foster et al. (2012) that we achieve a sample complexity N ≥","128k2 s2","ε2","Λ2 σ4 k log (","2k","δ ) · ≈1 { }} {","ε2 /s2","( s√ 1 + ε − 1)2 (7) leading to the theorem stated above.","Lastly, note that in reality one does not see Λ and σk but instead estimates of these quantities; Foster et al. (2012) shows how to incorporate the accuracy of the estimates into the sample complexity.","Acknowledgement: We would like to thank Emily Pitler for valuable feedback on the paper."]},{"title":"References","paragraphs":["Shay Cohen, Karl Stratos, Michael Collins, Dean Foster, and Lyle Ungar. Spectral learning of latent-variable pcfgs. In Association of Computational Linguistics (ACL), volume 50, 2012.","Michael Collins. Ranking algorithms for namedentity extraction: boosting and the voted perceptron. In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics, ACL ’02, pages 489–496, Stroudsburg, PA, USA, 2002. Association for Computational Linguistics. URL http://dx.doi.org/10. 3115/1073083.1073165. Michael Collins and Terry Koo. Discriminative reranking for natural language parsing. Comput. 212 Linguist., 31(1):25–70, March 2005. ISSN 0891-2017.","Koby Crammer, Ofer Dekel, Joseph Keshet, Shai Shalev-Shwartz, and Yoram Singer. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7:551–585, 2006.","A. P. Dempster, N. M. Laird, and D. B. Rubin. Maximum likelihood from incomplete data via the em algorithm. JRSS, SERIES B, 39(1):1–38, 1977.","Paramveer S. Dhillon, Dean Foster, and Lyle Ungar. Multi-view learning of word embeddings via cca. In Advances in Neural Information Processing Systems (NIPS), volume 24, 2011. Jason Eisner and Giorgio Satta. Efficient parsing for bilexical context-free grammars and headautomaton grammars. In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics (ACL), pages 457–464, University of Maryland, June 1999. URL http://cs. jhu.edu/j̃ason/papers/#acl99.","Dean Foster, Jordan Rodu, and Lyle Ungar. Spectral dimensionality reduction for HMMs. ArXiV http://arxiv.org/abs/1203.6130, 2012.","D Hsu, S M. Kakade, and Tong Zhang. A spectral algorithm for learning hidden markov models. arXiv:0811.4413v2, 2008.","Terry Koo, Xavier Carreras, and Michael Collins. Simple semi-supervised dependency parsing. In In Proc. ACL/HLT, 2008.","F. Luque, A. Quattoni, B. Balle, and X. Carreras. Spectral learning for non-deterministic dependency parsing. In EACL, 2012.","Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a large annotated corpus of english: the penn treebank. Comput. Linguist., 19:313–330, June 1993. ISSN 0891-2017.","Ryan McDonald. Discriminative learning and spanning tree algorithms for dependency parsing. PhD thesis, University of Pennsylvania, Philadelphia, PA, USA, 2006. AAI3225503.","Bernard Merialdo. Tagging english text with a probabilistic model. Comput. Linguist., 20:155–171, June 1994. ISSN 0891-2017. Gabriele Antonio Musillo and Paola Merlo. Unlexicalised hidden variable models of split dependency grammars. In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics on Human Language Technologies: Short Papers, HLT-Short ’08, pages 213– 216, Stroudsburg, PA, USA, 2008. Association for Computational Linguistics.","Ankur P. Parikh, Le Song, and Eric P. Xing. A spectral algorithm for latent tree graphical models. In ICML, pages 1065–1072, 2011.","Slav Petrov, Leon Barrett, Romain Thibaux, and Dan Klein. Learning accurate, compact, and in-terpretable tree annotation. In Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics, ACL-44, pages 433–440, Stroudsburg, PA, USA, 2006. Association for Computational Linguistics.","Ariadna Quattoni, Michael Collins, and Trevor Darrell. Conditional random fields for object recognition. In In NIPS, pages 1097–1104. MIT Press, 2004.","Lawrence R. Rabiner. A tutorial on hidden markov models and selected applications in speech recognition. In Proceedings of the IEEE, pages 257– 286, 1989.","Adwait Ratnaparkhi. A Maximum Entropy Model for Part-Of-Speech Tagging. In Eric Brill and Kenneth Church, editors, Proceedings of the Empirical Methods in Natural Language Processing, pages 133–142, 1996.","Sebastiaan Terwijn. On the learnability of hidden markov models. In Proceedings of the 6th International Colloquium on Grammatical Inference: Algorithms and Applications, ICGI ’02, pages 261–268, London, UK, UK, 2002. Springer-Verlag. ISBN 3-540-44239-1. 213"]}]}
