{"sections":[{"title":"Literal Movement Grammars Annius V. Groenink* CWI Kruislaan 413 1098 SJ Amsterdam The Netherlands avg@cwi,nl Abstract Literal movement grammars","paragraphs":["(LMGs) provide a general account of extraposition phenomena through an attribute mechanism allowing top-down displacement of syntactical information. LMGs provide a simple and efficient treatment of complex linguistic phenomena such as cross-serial dependencies in German and Dutch--separating the treatment of natural language into a parsing phase closely resembling traditional context-free treatment, and a disambiguation phase which can be carried out using matching, as opposed to full unification employed in most current grammar formalisms of linguistical relevance."]},{"title":"1 Introduction","paragraphs":["The motivation for the introduction of the"]},{"title":"literal movement grammars","paragraphs":["presented in this paper is twofold. The first motivation is to examine whether, and in which ways, the use of unification is essential to automated treatment of natural language. Unification is an expensive operation, and pinpointing its precise role in NLP may give access to more efficient treatment of language than in most (Prolog-based) scientific applications known today. The second motivation is the desire to apply popular computer-science paradigms, such as the theory of attribute grammars and modular equational specification, to problems in linguistics. These formal specification techniques, far exceeding the popular"]},{"title":"Prolog","paragraphs":["in declarativity, may give new in-sight into the formal properties of natural language, and facilitate prototyping for large language applications in the same way as they are currently being used to facilitate prototyping of programming language tools.","For an extensive illustration of how formal specification techniques can be made useful in the treatment of natural language, see (Newton, 1993) which describes the abstract specification of several accounts of phrase structure, features, movement, modularity and","*This work is supported by SION grant 612-317-420 of the Netherlands Organization for Scientific Research"]},{"title":"~wo). 90","paragraphs":["parametrization so as to abstract away from the exact language being modelled. The specification language (ASL) used by Newton is a very powerful formalism. The class of specification formalisms we have in mind includes less complex, equational techniques such as ASF+SDF (Bergstra et al., 1989) (van Deursen, 1992) which can be applied in practice by very efficient execution as a term rewriting system.","Literal movement grammars are a straightforward extension of context-free grammars. The derivation trees of an LMG analysis can be easily transformed into trees belonging to a context-free backbone which gives way to treatment by formal specification systems. In order to obtain an efficient implementation, some restrictions on the general form of the formalism are necessary."]},{"title":"1.1 Structural Context Sensitivity in Natural Language","paragraphs":["Equational specification systems such as the ASF+SDF system operate through sets of"]},{"title":"equations","paragraphs":["over signatures that correspond to arbitrary forms of context-free grammar. An attempt at an equational specification of a grammar based on context-free phrase structure rules augmented with feature constraints may be to use the context-free backbone as a signature, and then implement further analysis through equations over this signature. This seems entirely analoguous to the static semantics of a programming language: the language itself is context-free, and the static semantics are defined in terms of functions over the constructs of the language.","In computer-science applications it is irrelevant whether the evaluation of these functions is carried out during the parsing phase"]},{"title":"(I-pass treatment),","paragraphs":["or afterwards"]},{"title":"(2-pass treatment).","paragraphs":["This is not a trivial property of computer languages: a computer language with static semantics restrictions is a context-sensitive sublanguage of a context-free language that is either"]},{"title":"unambiguous","paragraphs":["or has the"]},{"title":"finite ambiguity","paragraphs":["property: for any input sentence, there is only a finite number of possible context-free analyses.","In section 1.3 we will show that due to phenomena of"]},{"title":"extraposition","paragraphs":["or"]},{"title":"discontinuous constituency","paragraphs":["exhibited by natural languages, a context-free backbone for a sufficiently rich fragment of natural language no longer has the property of finite ambiguity. Hence an initial stage of sentence processing cannot be based on a purely context-free analysis.","The LMG formalism presented in this paper at-tempts to eliminate infinite ambiguity by providing an elementary, but adequate treatment of movement. Experience in practice suggests that after relocating displaced constituents, a further analysis based on feature unification no longer exploits unbounded structural embedding. Therefore it seems that after LMG-analysis, there is no need for unification, and further analysis can be carried out through functional match-ing techniques."]},{"title":"1.2 Aims","paragraphs":["We aim to present a grammar formalism that","t~ is sufficiently powerful to model relevant fragments of natural language, at least large enough for simple applications such as an interface to a database system over a limited domain.","t, is sufficiently elementary to act as a front-end to computer-scientific tools that operate on context-free languages.","t~ has a (sufficiently large) subclass that allows efficient implementation through standard (Earley-based) left-to-right parsing techniques."]},{"title":"1.3 Requirements","paragraphs":["Three forms of movement in Dutch will be a leading thread throughout this paper. We will measure the adequacy of a grammar formalism in terms of its ability to give a unified account of these three phenomena. Topicalization The (leftward) movement of the objects of the verb phrase, as in","(1) [Which book]/ did John forget to return"]},{"title":"el","paragraphs":["to the library? Dutch sentence structure The surface order of sentences in Dutch takes three different forms: the finite verb appears inside the verb phrase in relative clauses; before the verb phrase in declarative clauses, and before the subject in questions: (2)"]},{"title":"... dat Jan [vP Marie kuste ]","paragraphs":["(3)"]},{"title":"Jan kustei [vP Marie el ]","paragraphs":["(4)"]},{"title":"kustei Jan [,ca Marie ei ] ?","paragraphs":["We think of these three (surface) forms a s merely being different representations of the same (deep) structure, and will take this deep structure to be the form (2) that does not show movement."]},{"title":"Cross-serial dependencies","paragraphs":["In Dutch and German, it is possible to construct sentences containing arbitrary numbers of crossed dependencies, such as in"]},{"title":"... dat Marie Jani Fredj Annek","paragraphs":["that (5)"]},{"title":"hoordei helpenj overtuigen k","paragraphs":["heard help convince (that Mary heard John help Fred convince Anne). Here the i, j, k denote which noun is the first object of which verb. The analysis we have in mind for this is"]},{"title":"dat Marie Jani Fredj Annek [ve hoorde el helpen ej overtuigen e~.]","paragraphs":["Note that this analysis (after relocation of the extraposed objects) is structurally equal to the corresponding English VP. The accounts of Dutch in this paper will consistently assign \"deep structures\" to sentences of Dutch which correspond to the underlying structure as it appears in English. Similar accounts can be given for other languages--so as to get a uniform treatment of a group of similar (European) languages such as German, French and Italian. If we combine the above three analyses, the final analysis of (3) will become"]},{"title":"Jan kustei Mariej [w el ej ]","paragraphs":["Although this may look like an overcomplication, this abundant use of movement is essential in any uniform treatment of Dutch verb constructions. Hence it turns out to occur in practice that a verb phrase has no lexical expansion at all, when a sentence shows both object and verb extraposition. Therefore, as conjectured in the introduction, a 2-pass treatment of natural language based on a context-free backbone will in general fail-- as there are infinitely many ways of building an empty verb phrase from a number of empty constituents."]},{"title":"2 Definition and Examples","paragraphs":["There is evidence that suggests that the typical human processing of movement is to"]},{"title":"first","paragraphs":["locate displaced information"]},{"title":"(the filler),","paragraphs":["and"]},{"title":"then","paragraphs":["find the logical location (the"]},{"title":"trace),","paragraphs":["to substitute that information. It also seems that by and large, displaced information appears earlier than (or left of) its logical position, as in all examples given in the previous section. The typical unification-based approach to such movement is to structurally analyse the displaced constituent, and use this analysed information in the treatment of the rest of the sentence. This method is called"]},{"title":"gap-threading;","paragraphs":["see (Alshawi, 1992).","If we bear in mind that a filler is usually found to the left of the corresponding trace, it is worth taking into consideration to develop a way of"]},{"title":"deferring treatment of syntactical","paragraphs":["data. E.g. for example sentence 1 this means that upon finding the displaced constituent"]},{"title":"which book,","paragraphs":["we will not evaluate that constituent, but rather remember during the treatment of the remaining part of the sentence, that this data is still to be fitted into a logical place.","This is not a new idea. A number of"]},{"title":"non-concatenative","paragraphs":["grammar formalisms has been put for-ward, such as"]},{"title":"head-wrapping grammars","paragraphs":["(HG) (Pollard, 1984),"]},{"title":"extraposition grammars","paragraphs":["(XG) (Pereira, 1981). and"]},{"title":"tree adjoining grammars","paragraphs":["(TAG) (Kroch and Joshi, 1986). A discussion of these formalisms as alternatives to the LMG formalism is given in section 4."]},{"title":"91","paragraphs":["Lessons in parsing by hand in high school (e.g. in English or Latin classes) informally illustrate the purpose of literal movement grammars: as opposed to the traditional linguistic point of view that there is only one head which dominates a phrase, constituents of a sentence have several key components. A verb phrase for example not only has its finite verb, but also one or more objects. It is precisely these key components that can be subject to movement. Now when such a key component is found outside the consitituent it belongs to, the LMG formalism implements a simple mechanism to pass the component down the derivation tree, where it is picked up by the constituent that contains its trace.","It is best to think of LMGs versus context-free grammars as a predicate version of the (propositional) paradigm of context-free grammars, in that nonterminals can have arguments. If we call the general class of such grammars predicate grammars, the distinguishing feature of LMG with respect to other predicate grammar formalisms such as indexed grammars I (Weir, 1988) (Aho, 1968) is the ability of binding or quantification in the right hand side of a phrase structure rule. 1 2.1 Definition We fix disjoint sets N, T, V of nonterminal symbols, terminal symbols and variables. We will write A, B, C... to denote nonterminal symbols, a, b, c... to denote terminal symbols, and x, y, z for variables. A sequence ala2. • • a,~ or a E T* is called a (terminal) word or string. We will use the symbols a, b, e for terminal words. (Note the use of bold face for sequences.) 1 2.2 Definition (term) A sequence tlt2...t~ or t E (V U T)* is called a term. If a term consists of variables only, we call it a vector and usually write x. 1 2.3 Definition (similarity type) A (partial) function # mapping N to the natural numbers is called a similarity type. 1 2.4 Definition (predicate) Let # be a similarity type, A E N and n = /~(A), and for 1 <_ i <_ n, let ti be a term. Then a predicate qa of type # is a terminal a (a terminal predicate) or a syntactical unit of the form A ( t l , t 2, • •., t,~ ), called a nonterminal predicate. If all t~ = xl are vectors, we say that","= A(a~l, ~e2,... , a~n) is apattern. Informally, we think of the arguments of a nonterminal as terminal words. A predicate A(x) then stands for a constituent A where certain information with terminal yield x has been extraposed (i.e. found outside the constituent), and must hence be left out of the A constituent itself. 1 2.5 Definition"]},{"title":"(item) Let/z be a","paragraphs":["similarity type, ~p a predicate of type #, and t a term. Then an item of type # is a syntactical unit of one of the following forms:","1 Indexed grammars are a weak form of monadic predicate grammar, as a nonterminal can have at most one argument. 1. qo (a nonterminal or terminal predicate) 2. x:~ (a quantifier item) 3. ~/t (a slash item) We will use ¢, qJ to denote items, and a,/3, 3' to denote sequences of items. 1 2.6 Definition Let /z be a similarity type. A rewrite rule R of type/2 is a syntactical unit qo ---, qbl (I)2 • ' • qb,~ where qo is a pattern of type #, and for I < i < n, ~i is an item of type #.","A literal movement grammar is a triple (#, S, P) where # is a similarity type, S E N, #(S) = 0 and P is a set of rewrite rules of type #. Items on the right hand side of a rule can either refer to variables, as in the following rule: A(x, yz) -~ BO/x a/y C(z) or bind new variables, as the first two items in","A 0 ---, x:B 0 y:C(x) D(y). A slash item such as B()/x means that x should be used instead of the actual \"input\" to recognize the nonterminal predicate B(). I.e. the terminal word x should be recognized as B0, and the item BO/x itself will recognize the empty string. A quantifier item x:B() means that a constituent B() is recognized from the input, and the variable x, when used elsewhere in the rule, will stand for the part of the input recognized. 1 2.7 Definition (rewrite semantics) Let R = A(Xh..., x,~) ~ ~1(I)2 ,.. ~rn be a rewrite rule, then an instantiation of R is the syntactical entity obtained by substituting for each i and for each variable x E xl a terminal word a~.","A grammar derives the string a iff S 0 =~ a where G ===~ is a relation between predicates and sequences of items defined inductively by the following axioms and inference rules: 2","G a~a G","qo ==* a when qo --* a is an instantiation","of a rule in G qo ~ /3 A(tl,...,t,~) 7 A(tl,...,t,~) ~ a MP G ,-t3 a 7"]},{"title":"-Lc,/3 ¢/a 7 /E","paragraphs":[":E"]},{"title":"(/3 a 3')[a/x]","paragraphs":["2Note that [a/x] in the :E rule is not an item, but stands for the substitution of a for z."]},{"title":"92","paragraphs":["B(aa) ~ a/a b B(a) c a~ a"]},{"title":"B(aa) ~ b B(a) c /E","paragraphs":["B(a) =~a"]},{"title":"a/a b","paragraphs":["B(e) c a~a B(a)~a b B(¢) c"]},{"title":"/E","paragraphs":["B(¢) =~"]},{"title":"B(a) =~G bc MP MP","paragraphs":["sO ~ x: A 0 B(x) A 0 ==~"]},{"title":"aa","paragraphs":["S 0 =~ aa B(aa)"]},{"title":"B(aa) ~ bbcc :E B(aa) =~G bbcc MP","paragraphs":["S 0 ~"]},{"title":"aabbcc","paragraphs":["Figure 1. Derivation of aabbcc. 1 2.8 Example (a'~b'~c '*) The following, very elementary LMG recognizes the trans-context free language anbnc n :"]},{"title":"s0 ~ ~:AO B(~)","paragraphs":["A 0 ---*"]},{"title":"a","paragraphs":["A 0 A 0 --~ B(xy) ~ a/x b B(y) c 8(6) ~ Figure 1 shows how aabbcc is derived according to the grammar. The informal tree analysis in figure 2"]},{"title":"s0","paragraphs":["A0"]},{"title":"a","paragraphs":["A 0"]},{"title":"6","paragraphs":["B(y) = B(aa)"]},{"title":"a/a b B(a) c a/a b","paragraphs":["B(e) c E 6 Figure 2. Informal tree analysis. illustrates more intuitively how displaced information (the two a symbols in this case) is 'moved back down' into the tree, until it gets 'consumed' by a slash item. It also shows how we can extract a context-free 'deep structure' for further analysis by, for example, formal specification tools: if we transform the tree, as shown in figure 3, by removing quantified (extraposed) data, and abstracting away from the parameters, we see that the grammar, in a sense, works by transforming the language anbnc n to the context-free language (ab)ncn. Figure 4 shows how we can derive a context free 'backbone grammar' from the original grammar."]},{"title":"12.9 Example (cross-serial dependencies in Dutch)","paragraphs":["The following LMG captures precisely the three basic types of extraposition defined in section 1.3: the three Dutch verb orders, topicalization and cross-serial verb-object dependencies."]},{"title":"s ~ s'(~)","paragraphs":["S'(e) -~ dat NP VP(e,e) S'(e) * n:NP S'(n) S'(n) -~ v:V NP VP(v,n) S'(e) ~ NP v:V VP(v,e)"]},{"title":"re(v, n) -~ m:NP W(v,,~m) VP(v,,~) --, V'(v, n) V(c, ~) --, v7 V(v, ~) --, Vt/v","paragraphs":["V(¢,n) -, VT NP/n V'(v, n) ~ VT/v NP/n 12(¢,nm) ---, VR NP/n 12(e,m) V(v, nm) ---* VR/v gP/n V(e,m) V ~ VI V --+ VT V ~ VR A sentence S' has one argument which is used, if nonempty, to fill a noun phrase trace. A VP has two S XP B a b B c a b B c"]},{"title":"I","paragraphs":["Figure 3. Context free backbone."]},{"title":"93","paragraphs":["S --,"]},{"title":"XPB","paragraphs":["B -~ abBc B -~ e XP -* e Figure 4. Backbone grammar. arguments: the first is used to fill verb traces, the second is treated as a list of noun phrases to which more noun phrases can be appended. A V' is similar to a"]},{"title":"VP","paragraphs":["except that it uses the list of noun phrases in its second argument to fill noun phrase traces rather than adding to it.","Figure 5 shows how this grammar accepts the sentence"]},{"title":"Marie zag Fred Anne kussen.","paragraphs":["We see that it is analyzed as"]},{"title":"Marie zag i Fredj Annek IV' ei ej [V, kussen e~","paragraphs":["]] which as anticipated in section 1.3 has precisely the basic, context-free underlying structure of the corresponding English sentence"]},{"title":"Mary saw Fred kiss Anne","paragraphs":["indicated in figure 5 by terminal words in bold face. Note that arbitrary verbs are recognized by a quantis()"]},{"title":"s'(e)","paragraphs":["! [ VP(v ~- zag, e') Marie z ag ~n~ ~....~ n","NP , = Fred)","n = Fred Anne) Fred p I Anne Vt(zag, Fred Anne) VR/~E, Anne) VT NP/Anne I :","kussen e Figure 5. Derivation of a Dutch sentence fier item"]},{"title":"v:V,","paragraphs":["and only when, further down the tree, a trace is filled with such a verb in items such as"]},{"title":"VR/v,","paragraphs":["its subcategorization types"]},{"title":"VI, VT","paragraphs":["and VR start playing a role."]},{"title":"3 Formal Properties","paragraphs":["The LMG formalism in its unrestricted form is shown to be Turing complete in (Groenink, 1995a). But the grammars presented in this paper satisfy a number of vital properties that allow for efficient parsing techniques.","Before building up material for a complexity result, notice the following proposition, which shows, using only part of the strength of the formalism, that the literal movement grammars are closed under intersection."]},{"title":"1 3.1 Proposition (intersection)","paragraphs":["Given two literal movement grammars G1 --- (#1,$1, P1) and"]},{"title":"Gz = (tzz, $2, Pz)","paragraphs":["such that dom(#l) n dom(#2) = O, we can construct the grammar GI = (#1 U #z U {(S, 0)}, S, P1 U P2 U {R}) where we add the rule R: so -~ =S,O"]},{"title":"Sz()/x","paragraphs":["Clearly,"]},{"title":"GI","paragraphs":["recognizes precisely those sentences which are recognized by both G1 and"]},{"title":"Gz.","paragraphs":["We can use this knowledge in example 2.9 to restrict movement of verbs to verbs of finite morphology, by adding a nonterminal"]},{"title":"VFIN,","paragraphs":["replacing the quantifier items"]},{"title":"v:V","paragraphs":["that locate verb fillers with"]},{"title":"v:VFIN,","paragraphs":["where"]},{"title":"VFIN","paragraphs":["generates all finite verbs. Any extraposed verb will then be required to be in the intersection of"]},{"title":"VFIN","paragraphs":["and one of the verb types"]},{"title":"VI, VT","paragraphs":["or VR, reducing possible ambiguity and improving the efficiency of left-to-right recognition. The following properties allow us to define restrictions of the LMG formalism whose recognition problem has a polynomial time complexity."]},{"title":"1 3.2 Definition (non-combinatorial)","paragraphs":["An LMG is"]},{"title":"non-combinatorial","paragraphs":["if every argument of a nonterminal on the RHS of a rule is a single variable (i.e. we do not allow composite terms within predicates). If G is a non-combinatorial LMG, then any terminal string occurring (either as a sequence of items or inside a predicate) in a full G-derivation is a substring of the derived string. The grammar of example 2.8 is non-combinatorial; the grammar of example 2.9 is not (the offending rule is the first"]},{"title":"VP","paragraphs":["production)."]},{"title":"1 3.3 Definition","paragraphs":["(left-binding) An LMG G is"]},{"title":"left-binding","paragraphs":["when","1. W.r.t. argument positions, an item in the RHS of a rule only depends on variables bound in items to its left.","2. For any vector x ~ • • • x,~ of n > 1 variables on the LHS, each of xl upto"]},{"title":"xn-~","paragraphs":["occurs in exactly one item, which is of the form qo/xl. Furthermore, for each 1 < I < k < n the item referring to xz appears left of any item referring to x~. For example, the following rule is left binding:"]},{"title":"A(xyz, v) ~ u:B(v) C(v)/x DO/y E(u,z)","paragraphs":["but these ones are not:"]},{"title":"(a) g(y) ---* C(x) x:D(y)","paragraphs":["(b)"]},{"title":"A(xy) ---* A(x) B(y)","paragraphs":["(c)"]},{"title":"A(xyz)~ A(z) BO/x CO/y 94","paragraphs":["because in (a), x is bound right of its use; in (b), the item"]},{"title":"A(x)","paragraphs":["is not of the form"]},{"title":"qo/x","paragraphs":["and in (e), the variables in the vector"]},{"title":"zyz","paragraphs":["occur in the wrong order"]},{"title":"(zzy).","paragraphs":["Ifa grammar satisfies condition 1, then for any deriv-able string, there is a derivation such that the modus ponens and elimination rules are always applied to the leftmost item that is not a terminal. Furthermore, the :E rule can be simplified to :E G The proof tree in example 2.8 (figure 1) is an example of such a derivation.","Condition 2 eliminates the nondeterminism in finding the right instantiation for rules with multiple variable patterns in their LHS.","Both grammars from section 2 are left-binding."]},{"title":"1 3.4 Definition (left-recursive)","paragraphs":["An LMG G is"]},{"title":"left-recursive","paragraphs":["if there exists an instantiated nonterminal","G predicate qa such that there is a derivation of ~o ~ ~pc~ for any sequence of items c~. The following two rules show that left-recursion in LMG is not always immediately apparent:"]},{"title":"A(y) ~ BO/Y A(e) B 0 ~","paragraphs":["for we have"]},{"title":"A(¢) ~ B()/¢ a(e) B 0 ~","paragraphs":["A(~) =:~ A(e)"]},{"title":"/E","paragraphs":["We now show that the recognition problem for an arbitrary left-binding, non-combinatorial LMG has a polynomial worst-case time complexity."]},{"title":"1 3.5 Theorem (polynomial complexity)","paragraphs":["Let G be a LMG of similarity type # that is non-combinatorial, left binding and not left-recursive. Let m be the maximum number of items on the right hand side of rules in G, and let p be the greatest arity of predicates occurring in G. Then the worst case time complexity of the recognition problem for G does not exceed"]},{"title":"O(IGIm(1 + p)nl+'~+2P),","paragraphs":["where n is the size of the input string"]},{"title":"ala2\" • .a,~. Proof","paragraphs":["(sketch) We adopt the memoizing recursive descent algorithm presented in (Leermakers, 1993). As G is not left-binding, the terminal words associated with variables occurring in the grammar rules can be fully determined while proceeding through sentence and rules from left to right. Because the grammar is non-combinatorial, the terminal words substituted in the argument positions of a nonterminal are always substrings of the input sentence, and can hence be represented as a pair of integers.","The recursive descent algorithm recursively computes set-valued recognition functions of the form: [~o](i) = {jl~o ~ ai+l\"\" .aj} where instead of a nonterminal as in the context-free case, qo is any instantiated nonterminal predicate"]},{"title":"A(bl,..., b,~).","paragraphs":["As bl,...,b,~ are continuous substrings of the input sentence"]},{"title":"ala2 • • • an,","paragraphs":["we can reformulate this as"]},{"title":"[A](i, (tl, r,),..., r,,)) = {jlA(ah+ 1...a,,,,...,at.+l...ar~)","paragraphs":["ai+ 1 • •. aj } Where # = #(A) < p. The arguments i, ll,...,l~, and rl,. •., r t, are integer numbers ranging from 0 to n - 1 and 1 to n respectively. Once a result of such a recognition function has been computed, it is stored in a place where it can be retrieved in one atomic operation. The number of such results to be stored is"]},{"title":"O(n)","paragraphs":["for each possible nonterminal and each possible combination of, at most 1 + 2p, arguments; so the total space complexity is O(IGIn2+2p).","Much of the extra complication w.r.t, the context-free case is coped with at compile time; for example, if there is one rule for nonterminal A:"]},{"title":"A(x,,x2) ~ x3:Ba(xj) B2() B3(x3)/x2","paragraphs":["then the code for [g](i, (ll, r,), (12, r2)) will be"]},{"title":"result","paragraphs":[":= empty","for kl E [B1](i, (/1, rl)) do 13 := i r 3 := k 1"]},{"title":"rot e for","paragraphs":["k 3 e [B3](/2, (/3, r3)) if (k 3 =: r2)","add k2 to"]},{"title":"result","paragraphs":["return"]},{"title":"result","paragraphs":["The extra effort remaining at parse time is in copy-ing arguments and an occasional extra comparison (the if statement in the example), taking rn(1 + p) steps everytime the innermost for statement is reached, and the fact that not"]},{"title":"O(n),","paragraphs":["but O(n l+2p) argument-value pairs need to be memoized. Merging the results in a RHS sequence of rn items can be done in O(m(1 +"]},{"title":"p)n ~-1)","paragraphs":["time. The result is a set of"]},{"title":"O(n)","paragraphs":["size. As there are at most"]},{"title":"O(IGln 1+2p)","paragraphs":["results to be computed, the overall time complexity of the algorithm is"]},{"title":"O(IGIm(1 +","paragraphs":["p)nl+m+2P). [] | 3.6 Remark If all nonterminals in the grammar are nullary (p = 0), then the complexity result coincides with the values found for the context-free recursive descent algorithm (Leermakers, 1993). Nullary LMG includes the context-free case, but still allows movement local to a rule; the closure result 3.1 still holds for this class of grammars. As all we can do with binding and slashing local to a rule is intersection, the nullary LMGs must be precisely the closure of the context-free grammars under finite intersection. These results can be extended to more efficient algorithms which can cope with left-recursive grammars such as memoizing"]},{"title":"recursive ascent","paragraphs":["(Leermakers, 1993). A very simple improvement is obtained by bilinearizing the grammar (which is possible if it"]},{"title":"95","paragraphs":["is left binding), giving a worst case complexity of"]},{"title":"o(Ic[(1 + p)n3+2,). 4 Other Approaches to Separation of Movement","paragraphs":["A natural question to ask is whether the LMG formalism (for the purpose of embedding in equational specification systems, or eliminating unification as a stage of sentence processing) really has an advantage over existing mildly context-sensitive approaches to movement. Other non-concatenative formalisms are head-wrapping grammars (HG) (Pollard, 1984), extraposition grammars (XG) (Pereira, 1981) and various exotic forms of tree adjoining grammar (Kroch and Joshi, 1986). For overviews see (Weir, 1988), (Vijay-Shanker et al., 1986) and (van Noord, 1993). The most applicable of these formalisms for our purposes seem to be HG and XG, as both of these show good results in modeling movement phenomena, and both are similar in appearance to context-free grammars; as in LMG, a context-free grammar has literally the same representation when expressed in HG or XG. Hence it is to be expected that incorporating these approaches into a system based on a context-free front-end will not require a radical change of perspective. 4.1 Head Grammars A notion that plays an important role in various forms of Linguistic theory is that of a head. Although there is a great variation in the form and function of heads in different theories, in general we might say that the head of a constituent is the key component of that constituent. The head grammar formalism, introduced by Pollard in (Pollard, 1984) divides a constituent into three components: a left context, a terminal head and a right context. In a HG rewrite rule these parts of a constituent can be addressed separately when building a constituent from a number of subconstituents.","An accurate and elegant account of Dutch cross-serial dependencies using HG is sketched in (Pollard, 1984). However, we have not been able to construct head grammars that are able to model verb movement, cross-serial dependencies and topicalization at the same time. For every type of constituent, there is only one head, and hence only one element of the constituent that can be the subject to movement. 3 4.2 Extraposition Grammars Whereas head grammars provide for an account of verb fronting and cross-serial dependencies, Pereira,","3However, a straightforward extension of head grammars defined in (Groenink, 1995a) which makes use of arbitrary tupies, rather than dividing constituents into three components, is (1) capable of representing the three target phenomena of Dutch all at once and (2) weakly equivalent to a (strongly limiting) restriction of literal movement grammars. Head grammars and their generalizations, being linear context-free rewriting systems (Weir, 1988), have been shown to have polynomial complexity. introducing extraposition grammars in (Pereira, 1981), is focused on displacement of noun phrases in English. Extraposition grammars are in appearance very similar to context-free grammars, but allow for larger patterns on the left hand side of PS rules. This makes it possible to allow a topicalized NP only if somewhere to its right there is an unfilled trace:","S --~ Topic S Topic . . . XP --* NP While XG allows for elegant accounts of cross-serial dependencies and topicalization, it seems again hard to simultaneously account for verb and noun movement, especially if the bracketing constraint introduced in (Pereira, 1981), which requires that XG derivation graphs have a planar representation, is not relaxed. 4","Furthermore, the practical application of XG seems to be a problem. First, it is not obvious how we should interpret XG derivation graphs for further analysis. Second, as Pereira points out, it is nontrivial to make the connection between the XG formalism and standard (e.g. Earley-based) parsing strategies so as to obtain truly efficient implementations."]},{"title":"5 Conclusions","paragraphs":["We have presented the LMG formalism, examples of its application, and a complexity result for a constrained subclass of the formalism. Example 2.9 shows that an LMG can give an elegant account of movement phenomena. The complexity result 3.5 is primarily in-tended to give an indication of how the recognition problem for LMG relates to that for arbitrary context free grammars. It should be noted that the result in this paper only applies to non-combinatorial LMGs, excluding for instance the grammar of example 2.9 as presented here.","There are other formalisms (HG and XG) which provide sensible accounts of the three movement phenomena sketched in section 1.3, but altogether do not seem to be able to model all phenomena at once. In (Groenink, 1995b) we give a more detailed analysis of what is and is not possible in these formalisms. Future Work 1. The present proof of polynomial complexity does not cover a very large class of literal movement grammars. It is to be expected that larger, Turing complete, classes will be formally intractable but behave reasonably in practice. It is worthwile to look at possible practical implementations for larger classes of LMGs, and investigate the (theoretical and practical) performance of these systems on various representative grammars.","2. Efficient treatment of LMG strongly depends on the left-binding property of the grammars, which","4Theoretically simultaneous treatment of the three movement phenomena is not impossible in XG (a technique similar topit-stopping in GB allows one to wrap extrapositions over natural bracketing islands), but grammars and derivations become very hard to understand."]},{"title":"96","paragraphs":["seems to restrict grammars to treatment of"]},{"title":"leftward extraposition.","paragraphs":["In reality, a smaller class of"]},{"title":"rightward","paragraphs":["movement phenomena will also need to be treated. It is shown in (Groenink, 1995b) that these can easily be circumvented in left-binding LMG, by introducing artificial, \"parasitic\" extraposition."]},{"title":"Acknowledgements","paragraphs":["I would like to thank Jasper Kamperman, Ren6 Leermakers, Jan van Eijck and Eelco Visser for their enthousiasm, for carefully reading this paper, and for many general and technical comments that have contributed a great deal to its consistency and readability. David J. Weir. 1988."]},{"title":"Characterizing Mildly Context-Sensitive Grammar Formalisms.","paragraphs":["Ph.D. thesis, University of Pennsylvania."]},{"title":"References","paragraphs":["A.V. Aho. 1968. Indexed Grammars -an Extension to Context-free grammars."]},{"title":"JACM,","paragraphs":["15:647-671. Hiyan Alshawi, editor. 1992."]},{"title":"The Core Language Engine.","paragraphs":["MIT Press. J.A. Bergstra, J. Heering, and P. Klint, editors. 1989."]},{"title":"Algebraic Specification.","paragraphs":["ACM Press Frontier Series. The ACM Press in co-operation with Addison-Wesley.","Annius V. Groenink. 1995a. Accounts of Movement--a Formal Comparison. Unpublished manuscript.","Annius V. Groenink. 1995b. Mechanisms for Movement. Paper presented at the 5th CLIN (Computational Linguistics In the Netherlands) meeting, November 1994.","A.S. Kroch and A.K. Joshi. 1986. Analyzing Extraposition in a TAG. In Ojeda Huck, editor,"]},{"title":"Syntax and Semantics: Discontinuous Constituents.","paragraphs":["Acad. Press, New York.","Ren6 Leermakers. 1993."]},{"title":"The Functional Treatment of Parsing.","paragraphs":["Kluwer, The Netherlands. Michael Newton. 1993."]},{"title":"Formal Specification of Grammar.","paragraphs":["Ph.D. thesis, University of Edinburgh. Fernando Pereira. 1981. Extraposition Grammars."]},{"title":"Computational Linguistics,","paragraphs":["7(4):243-256. Carl J. Pollard. 1984."]},{"title":"Generalized Phrase Structure Grammars, Head Grammars, and Natural Language.","paragraphs":["Ph.D. thesis, Standford University.","Arie van Deursen. 1992. Specification and Genera-tion of a A-calculus environment. Technical report, CWI, Amsterdam. Published in revised form in Van Deursen,"]},{"title":"Executable Language Definitions--Case Studies and Origin Tracking,","paragraphs":["PhD Thesis, University of Amsterdam, 1994.","Gertjan van Noord. 1993."]},{"title":"Reversibility in Natural Language.","paragraphs":["Ph.D. thesis, Rijksuniversiteit Groningen.","K. Vijay-Shanker, David J. Weir, and A.K. Joshi. 1986. Tree Adjoining and Head Wrapping. In"]},{"title":"11th int. conference on Computational Linguistics. 97","paragraphs":[]}]}