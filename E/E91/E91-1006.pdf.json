{"sections":[{"title":"","paragraphs":["BIDIRECTIONAL PARSING OF LEXICALIZED TREE ADJOINING GRAMMARS* Alberto Lavelli and Giorgio Satta","Istituto per ia Ricerca Scientifica e Teenologica","I - 38050 Povo TN, Italy e-mail: lavelli/satta@irst.it Abstract","In this paper a bidirectional parser for Lexicalized Tree Adjoining Grammars will be presented. The algorithm takes advantage of a peculiar characteristic of Lexicalized TAGs, i.e. that each elementary tree is associated with a lexical item, called its anchor. The algorithm employs a mixed strategy: it works bottom-up from the lexical anchors and then expands (partial) analyses making top-down predictions. Even if such an algorithm does not improve tim worst-case time bounds of already known TAGs parsing methods, it could be relevant from the perspective of linguistic information processing, because it employs lexical information in a more direct way. 1. Introduction","Tree Adjoining Grammars (TAGs) are a formal-ism for expressing grammatical knowledge that extends the domain of locality of context-free grammars (CFGs). TAGs are tree rewriting systems specified by a finite set of elementary trees (for a detailed description of TAGs, see (Joshi, 1985)). TAGs can cope with various kinds of unbounded dependencies in a direct way because of their extended domain of locality; in fact, the elementary trees of TAGs are the appropriate domains for characterizing such dependencies. In (Kroch and Joshi, 1985) a detailed discussion of the linguistic relevance of TAGs can be found.","Lexicalized Tree Adjoining Grammars (Schabes et al., 1988) are a refinement of TAGs such that each elementary tree is associated with a lexieal item, called the anchor of the tree. Therefore, Lexicalized TAGs conform to a common tendency in modem theories of grammar, namely the attempt to embed grammatical information within lexical items. Notably, the association between elementary trees and anchors improves also parsing performance, as will be discussed below.","Various parsing algorithms for TAGs have been proposed in the literature: the worst-case time complexity varies from O(n 4 log n) (Harbusch, 1990) to O(n 6) (Vijay-Shanker and Joshi, 1985, Lang, 1990, Schabes, 1990) and O(n 9) (Schabes and Joshi, 1988). *Part of this work was done while Giorgio Satta was completing his Doctoral Dissertation at the University of Padova (Italy). We would like to thank Yves Schabes for his valuable comments. We would also like to thank Anne Abeill6. All errors are of course our own. As for Lexicalized TAGs, in (Schabes et al., 1988) a two step algorithm has been presented: during the first step the trees corresponding to the input string are selected and in the second step the input string is parsed with respect to this set of trees. Another paper by Schabes and Joshi (1989) shows how parsing strategies can take advantage of lexicalization in order to improve parsers' performance. Two major advantages have been discussed in the cited work: grammar filtering (the parser can use only a subset of the entire grammar) and bottom-up information (further constraints are imposed on the way trees can be combined). Given these premises and starting from an already known method for bidirectional CF language recognition (Satta and Stock, 1989), it seems quite natural to propose an anchor-driven bidirectional parser for Lexicalized TAGs that tries to make more direct use of the information contained within the anchors. The algorithm employs a mixed strategy: it works bottom-up from the lexical anchors and then expands (partial) analyses making top-down predictions. 2. Overview of the Algorithm","The algorithm that will be presented is a recognizer for Tree Adjoining Languages: a parser can be obtained from such a recognizer by additional processing (see final section). As an introduction to the next section, an informal description of the studied algorithm is here presented. We assume the following definition of TAGs. Definition 1 A Tree Adjoining Grammar (TAG) is a 5-tuple G=(VN, Vy, S, l, A), where VN is a finite set of non-terminal symbols, Vy is a finite set of terminal symbols, Se VN is the start symbol, 1 and A are two finite sets of trees, called initial trees and auxiliary trees respectively. The trees in the set IuA are called elementary trees.","We assume that the reader is familiar with the definitions of adjoining operation and foot node (see 0oshi, 1985)).","The proposed algorithm is a tabular method that accepts a TAG G and a string w as input, and decides whether we L(G). This is done by recovering (partial) analyses for substrings of w and by combin-ing them. More precisely, the algorithm factorizes analyses of derived trees by employing a specific structure called state. Each state retains a pointer to a node n in some tree ae luA, along with two additional pointers (called Idol and rdot) to n itself or to - 27 - its children in a. Let an be a tree obtained from the maximal subtree of a with root n, by means of some adjoining operations. Informally speaking and with a little bit of simplification, the two following cases are possible. First, ff"]},{"title":"ldot, rdo~n, state s","paragraphs":["indicates that the part of an dominated by the nodes"]},{"title":"between ldot","paragraphs":["and"]},{"title":"rdot","paragraphs":["has already been analyzed by the algorithm. Second, if"]},{"title":"ldot=rdot=n,","paragraphs":["state s indicates that the whole of an has already been analyzed, including possible adjunctions to its root n.","Each state s will be inserted into a recognition matrix T, which is a square matrix indexed from 0 to"]},{"title":"nw,","paragraphs":["where"]},{"title":"nw","paragraphs":["is the length of w. If state s belongs to the component"]},{"title":"tij","paragraphs":["of T, the partial analysis (the part of an) represented by s subsumes the substring of w that starts from position i and ends at position j, except for the items dominated by a possible foot node in an (this is explicitly indicated within s).","The algorithm performs the analysis of w starting from the anchor node of every tree in G whose category is the same as an item in w. Then it tries to extend each partial analysis so obtained, by climbing each tree along the path that connects the anchor node to the root node; in doing this, the algorithm recognizes all possible adjunctions that are present in w. Most important, every subtree 7'of a tree derived from"]},{"title":"aEluA,","paragraphs":["such that 7'd0es not contain the anchor node of a, is predicted and analyzed by the algorithm in a top-down fashion, from right to left (left to right) if it is located to the left (right) of the path that connects the anchor node to the root node in a.","The combinations of partial analyses (states) and the introduction of top-down prediction states is carried out by means of the application of six procedures that will be defined below. Each procedure applies to some states, trying to \"move\" outward one of the two additional pointers within each state.","The algorithm stops when no state in T can be further expanded. If some state has been obtained that subsumes the input string and that represents a complete analysis for some tree with the root node of category S, the algorithm succeeds in the recognition. 3. The Algorithm","In the following any (elementary or derived) tree will be denoted by a pair"]},{"title":"(N, E),","paragraphs":["where N is a finite set of"]},{"title":"nodes","paragraphs":["and E is a set of ordered pairs of nodes, called"]},{"title":"arcs.","paragraphs":["For every tree"]},{"title":"a=(N, E),","paragraphs":["we define five functions of N into Nu {_1_} ,l"]},{"title":"called father, leftmostchild, rightmost-child, left-sibling, and right-sibling","paragraphs":["(with the obvious meanings). For every tree"]},{"title":"a=(N, E)","paragraphs":["and every node"]},{"title":"n~N,","paragraphs":["a function"]},{"title":"domaina","paragraphs":["is defined such that"]},{"title":"domaindn)-'~,","paragraphs":["where/3 is the maximal subtree in a whose root is n. IThe symbol \"_1_\" denotes here the undefined element. For any"]},{"title":"TAG G","paragraphs":["and for every node n in some tree in G, we will write"]},{"title":"cat(n)=X, X~ VNuVZ,","paragraphs":["whenever X is the symbol associated to n in G. For every node n in some tree in G, such that"]},{"title":"cat(n)~","paragraphs":["VN, the set"]},{"title":"Adjoin(n)","paragraphs":["contains all root nodes of auxiliary trees that can be adjoined to n in G. Furthermore, a function x is defined such that, for every"]},{"title":"tree a~ luA,","paragraphs":["it holds that"]},{"title":"z(a)=n,","paragraphs":["where n indicates the anchor node of a. In the following we assume that the anchor nodes in G are not labelled by the null (syntactic) category symbol e. The set of all nodes that dominate the anchor node of some tree in"]},{"title":"IuA","paragraphs":["will be called"]},{"title":"Middle-nodes","paragraphs":["(anchor nodes included); for every tree"]},{"title":"a=(N, E), the","paragraphs":["nodes"]},{"title":"nEN","paragraphs":["in"]},{"title":"Middle-nodes","paragraphs":["divide a in two (possibly empty) left and right portions. The set"]},{"title":"Left-nodes (Right-nodes)","paragraphs":["is defined as the set of all nodes in the left (right) portion of some tree in"]},{"title":"IuA.","paragraphs":["Note that the three sets"]},{"title":"Middle-nodes, Left-nodes and Right-nodes","paragraphs":["constitute a partition of the set of all nodes of trees in"]},{"title":"IuA.","paragraphs":["The set of all foot nodes in the trees in A will be called"]},{"title":"Foot-nodes: Let w---a I ... anw, nw >1,","paragraphs":["be a symbol string; we will say that"]},{"title":"nw is the","paragraphs":["length of w. Definition 2 A"]},{"title":"state","paragraphs":["is defined to be any 8-tuple"]},{"title":"[n, ldot, lpos, rdot, rpos, fl, fr, m]","paragraphs":["such that:"]},{"title":"n, ldot, rdot are","paragraphs":["nodes in some tree ~"]},{"title":"IuA; lpos, rpos~ {left, right}; fl, fr are","paragraphs":["either the symbol \"-\" or indices in the input string such"]},{"title":"thatfl<fr;","paragraphs":["mE {-,"]},{"title":"rm, Ira}.","paragraphs":["The first component in a state s indicates a node n in some tree a, such that s represents some partial analysis for the subtree"]},{"title":"domaina(n).","paragraphs":["The second component"]},{"title":"(ldot)","paragraphs":["may be n or one of its children in if"]},{"title":"lpos=left, domaina(ldot)","paragraphs":["is included in the partial analysis represented by s, otherwise it is not. The components"]},{"title":"rdot and rpos","paragraphs":["have a symmetrical interpretation. The pair"]},{"title":"fl, fr","paragraphs":["represents the part of the input string that is subsumed by the possible foot node in"]},{"title":"domaina(n).","paragraphs":["A binary operator indicated with the symbol • is defined to combine the components"]},{"title":"fl, fr","paragraphs":["in different states; such an operator is defined as follows:"]},{"title":"f~f equalsfiff= -,","paragraphs":["it equalsf if f= -, and it is undefined otherwise. Finally, the component m is a marker that will be used to block expansion at one side for a state that has already been subsumed at the other one. This particular technique is called"]},{"title":"subsumption test","paragraphs":["and is discussed in (Satta and Stock, 1989). The subsumption test has the main purpose of blocking analysis proliferation due to the bidirectional behaviour of the method.","Let"]},{"title":"IS","paragraphs":["be the set of all possible states; we will use a particular equivalence relation O.C-"]},{"title":"Isxls","paragraphs":["defined as follows. For any pair of states"]},{"title":"s, s', sO.s\"","paragraphs":["holds if and only if every component in s but the last one (the m component) equals the corresponding - 28 - component in"]},{"title":"s'.","paragraphs":["The algorithm that will be presented employs the following function. Definition 3 A function F is defined as follows: 2"]},{"title":"F: V~, -.> ~(Is) F(a) = {s I s=[father(n), n, left, n, right, -, -, -], cat(n)=a and z(oO=n","paragraphs":["for some tree"]},{"title":"ot~ IuA }","paragraphs":["The details of the algorithm are as follows. Algorithm 1 Let"]},{"title":"G=(VN, Vy, S, I, A) be a TAG","paragraphs":["and let"]},{"title":"w=al ... anw, nw >--1, be","paragraphs":["any string in V~*. Let Tbe a recognition matrix of size"]},{"title":"(nw+l)x(nw+l)","paragraphs":["whose components"]},{"title":"tij are","paragraphs":["indexed from 0 to"]},{"title":"nw","paragraphs":["for both sides. Developmatrix T in the following way (a new slate s is added to some entry in T only if"]},{"title":"SOjq","paragraphs":["does not hold for any slate"]},{"title":"Sq","paragraphs":["already present in that entry). 1. For every slate se"]},{"title":"F(ai), l<i<-nw,","paragraphs":["add"]},{"title":"s to ti-l,i.","paragraphs":["2. Process each slate s added to some entry in T by means of the following procedures (in any order):"]},{"title":"Left-expander(s), Right-expander(s), Move-dot-left(s), Move-dot-right(s), Completer(s), Adjoiner(s);","paragraphs":["until no state can be further added. 3. if"]},{"title":"s=[n, n, left, n, right,-, -, -]e to,nw","paragraphs":["for some node n such that"]},{"title":"cat(n)=S","paragraphs":["and n is the root of a tree in I, then"]},{"title":"output(true)',","paragraphs":["else"]},{"title":"output(false).","paragraphs":["C3","The six procedures mentioned above are defined in the following. Procedure 1"]},{"title":"Left-expander Input","paragraphs":["A state"]},{"title":"s=[n, ldot. lpos, rdot, rpos, fl, fr, m]","paragraphs":["in"]},{"title":"ti,j. Precondition me-Ira, ldot~n and lpos=right. Description","paragraphs":["Case 1:"]},{"title":"ldot~ VN, ldot~ Foot-nodes.","paragraphs":["Step 1: For every state"]},{"title":"s'~[ldot, ldot, left, ldot, right, fl\", fr\",","paragraphs":["-] in"]},{"title":"ti',i, i'<_i,","paragraphs":["add slate"]},{"title":"s'=[n, ldot, left, rdot, rpos, fl~fl '', frOfr '', -] to ti,j;","paragraphs":["set"]},{"title":"m=rm","paragraphs":["in s if left-expansion is successful:, Step 2: Add state"]},{"title":"s'=[ldot, ldot, right, ldot, right, -, -, -] to ti, i.","paragraphs":["For every state"]},{"title":"s\"=[n\", n\", left, n\", right, fl\", fr\",","paragraphs":["\"] in"]},{"title":"ti',i, i'<i, n\" ~ Adjoin( ldot ),","paragraphs":["add state"]},{"title":"s'=[ ldot, ldot, right, ldot, right,","paragraphs":["-, -, -]"]},{"title":"to tfr\"fr\".","paragraphs":["Case 2:"]},{"title":"ldotE V~.. 3","paragraphs":["If"]},{"title":"ai=cat(ldot),","paragraphs":["add state"]},{"title":"s~[n, ldot, left, rdot, rpos, fi, fr,-] to ti-Ij (if eat(ldot)=e,","paragraphs":["i.e. the null category symbol, add state s' to"]},{"title":"tij);","paragraphs":["set"]},{"title":"m=rm","paragraphs":["in s if left-expansion is successful. Case 3:"]},{"title":"ldot~ Foot-nodes.","paragraphs":["Add state"]},{"title":"s~[n, ldot, left, rdot, rpos, i', i, -] to","paragraphs":["2Given a generic set ;1, the symbol P(.,q) denotes the set of all the subsets of .,~ (the"]},{"title":"power set","paragraphs":["of ,~). 3We assume that a 0 is undefined."]},{"title":"ti, J,","paragraphs":["for every i'<~, and set"]},{"title":"m=rm","paragraphs":["in s. Q Procedure 2"]},{"title":"Right-expander Input A slate s=[n, ldot, lpos, rdot, rpos, fl, fr, m]","paragraphs":["in"]},{"title":"tij. Precondition m#m, rdotg-n","paragraphs":["and"]},{"title":"rpos=-left. Description","paragraphs":["Case 1:"]},{"title":"rdot~ VN, rdot~ Foot-nodes.","paragraphs":["Step 1: For every slate"]},{"title":"s\"=[rdot, rdot, left, rdot.","paragraphs":["•","te","to °",".~",",t","t"]},{"title":"rtght, fl , fr , \"] m tj,j,, j~_j ,","paragraphs":["add state"]},{"title":"s =[n, ldot, lpos, rdot, right, flOfl\", fr~fr\", \"] to ti","paragraphs":["\"'; set"]},{"title":"m=lm","paragraphs":["in s if left-expansion is d successful;","Step 2: Add state"]},{"title":"s~[rdot, rdot, left, rdot, left, -o","paragraphs":["-, -] to"]},{"title":"tjj.","paragraphs":["For every slate s\"--[n\", n\","]},{"title":"left, n'~, right, fl\", fr'.","paragraphs":["\"] in"]},{"title":"tj,j., j<j', n\" ~ Adjoin(rdot), add state s'=[rdot, rdot, left, rdot, left, -, -, -] to tfr\"f/'.","paragraphs":["Case 2:"]},{"title":"rdote V~. 4","paragraphs":["If"]},{"title":"aj+l=cat(rdot),","paragraphs":["add state"]},{"title":"s~[n, ldot, lpos, rdot, rigl~t, fl,fr, \"] to ti,j+l","paragraphs":["(if"]},{"title":"cat(rdot)=e,","paragraphs":["i.e. the null category symbol, add state s' to"]},{"title":"tij);","paragraphs":["set"]},{"title":"m=Im","paragraphs":["in s if right-~xpansion is successful. Case 3:"]},{"title":"rdot¢ Foot-nodes.","paragraphs":["Add state"]},{"title":"s-in, ldot, lpos, rdot, right, j, j', -] to tij',","paragraphs":["for every"]},{"title":"j<j',","paragraphs":["and set"]},{"title":"m=lm","paragraphs":["in s. t3 Procedure 3"]},{"title":"Move-dot-left Input","paragraphs":["A slate"]},{"title":"s=[n, ldot, lpos, rdot, rpos, fl, fr, m]","paragraphs":["in"]},{"title":"tij. Precondition m~lm,","paragraphs":["and"]},{"title":"ldot~n, lpos=left,","paragraphs":["or"]},{"title":"ldot=n, lpos=right. Description","paragraphs":["Case 1:"]},{"title":"lpos=right. ~","paragraphs":["Add slate"]},{"title":"s~[n, rightmost-child(n), right, rdot, rpos, fl, fr, -] to tij; set m=rm","paragraphs":["in s; Case 2:"]},{"title":"lpos=left, left-sibling(n)~l.","paragraphs":["Add state"]},{"title":"s'=[n, left-sibling(ldot), right, rdot, rpos, fl, fr, \"] to tij;","paragraphs":["set"]},{"title":"m=rm","paragraphs":["in s. Case 3:"]},{"title":"lpos=-left, left-sibling(ldot)=±.","paragraphs":["Add slate"]},{"title":"s'=[n, n, left, rdot, rpos, fl, fr, -]","paragraphs":["to"]},{"title":"tij","paragraphs":["and set"]},{"title":"m=rm","paragraphs":["in s. (3 Procedure 4"]},{"title":"Move-dot-right Input A slate s=[n, ldot, lpos, rdot, rpos, fl,fr, m]","paragraphs":["in"]},{"title":"tij. Precondition m#rm, and rdot~n, rpos=right,","paragraphs":["or"]},{"title":"rdot=n, rpos=-left. Description","paragraphs":["Case 1:"]},{"title":"rpos=left.","paragraphs":["Add slate"]},{"title":"s'=[n, ldot, lpos, leftmost-child(n), left, fl, fr,","paragraphs":["-] to"]},{"title":"tij;","paragraphs":["set"]},{"title":"m=lm","paragraphs":["in s; Case 2:"]},{"title":"rpos=right, right-sibling(n)~Z.","paragraphs":["Add state"]},{"title":"s~[n, ldot, lpos, right-sibling(rdoO, left, fl, fr, \"] to ti4; set m=lm","paragraphs":["in s. Case 3:"]},{"title":"rpos=right, rtght-sibling(ldot)=±.","paragraphs":["Add state"]},{"title":"s'=[n, ldot, lpos, n, right, fl,fr,","paragraphs":["-] to"]},{"title":"tij","paragraphs":["and set"]},{"title":"m=lm","paragraphs":["in s. Q 4See note 3. - 29 -","Procedure 5 Completer","Input A state s=[n, n, left, n, right, fl, fr, m] in tij.","Precondition n is not the root of an auxiliary tree.","Description","Case 1: nE Middle-nodes. Add state s'=[father(n), n, left, n, right, fl, fr, -]","to ti~ j.","Case 2: n~Left-nodes. For every state s\"=[n\", Idol\", right, rdot, rpos, fl\", fr\", m\"] in t'f,j ,J'>J', such ,that ldot\"=n and m\"~lm, add state s =[n , idol', left, rdot, rpos, fluff', fr@fr\", \"] in tif; if left-expansion is successful for slate s', set m =rm in s.","Case 3: nERight-nodes. For every state s\"=[n\", Idol, lpos, rdot\", left, ff', f,\", m'q in ti',i, i'<i, such that rdot\"=n and m\"#rm, add state s- [n\", Idol, lpos, rdot\", right,","H","pt","•",",","•","•","* ffi~ft , f,~gf, , -] m ti',j, ff nght-expansmn is successful for state s\", set m\"--lm in s\". ~.","Procedure 6 Adjoiner","Input A state s=[n, n, left, n, right, fl, fr, m] in tij.","Precondition Void.","Description","Case 1: apply always.","For every state s\"=[n\", n\", left, n \", right, i, j, -] •","~",".t~","•",".","•","t¢","•","•","m ti'~, t _t,j~_j, n eAdjom(n), add state s'=[n,","n, lelt, n, right, fl, fr, \"] to ti'd'.","Case 2: n is the root of an auxiliary tree.","Step 1: For every state s\"=[n\", n\", left, n\",","~l_,fn such that right, ff', fr\", \"] in \", n , left, n , n~ Adjoin(n\"), add state \"' right, ff', fr\", -] to ti~; ,","Step 2: For every state s =[n', Idol\", right, rdot, rpos, ft\", fr\", m\"] in tj.j,,,j'>j, such that ne Adjoin(Idol\") and m ~lm, add state s'=[ldot\", Idol\", right, Idol\", right, -, -, -] to","Stepl~/:r'For every state s\"=[n\", Idol, lpos, rdot\", left, ft\", fr\", m'q in ti',i, i\" <i, such that n~Adjoin(rdot\") and m\"~rm, add state s'=[rdot\", rdot\", left, rdot\", left, -, -, -] to tftft. (:2","4. Formal Results","Some definitions will be introduced in the following, in order to present some interesting properties of Algorithm I. Formal proofs of the statements below can be found in (Satta, 1990).","Let n be a node in some tree a~l~A. Each state s=[n, Idol, lpos, rdot, rpos, fl, fr, m] in I S identifies a tree forest ¢(s) composed of all maximal subtrees in a whose roots are \"spanned\" by the two positions Idol and rdot. If ldot~n, we assume that the maximal subtree in a whose root is Idol is included in ¢(s) if and only if lpos=left (the mirror case holds w.r.t. rdot). We define the subsumption relation < on I S as follows: s~_s' iff state s has the same first component as state s' and ¢(s) is included in ¢(s9. We also say that a forest ¢(s) derives a forest ~ (¢(s) =~ ~) whenever I//can be obtained from ~(s) by means of some adjoining operations. Finally, E denotes the immediate dominance relation on nodes of ae IuA, and ~(a) denotes the foot node of a (if a~ A). The following statement characterizes the set of all states inserted in T by Algorithm 1.","Theorem 1 Let n be a node in a~ IuA and let n'","be the lowest node in a such that n'~ Middle-nodes","and (n, n°)EE*; let also s=[n, Idol, lpos, rdot, rpos,","fl, fr, m] be a state in I S. Algorithm 1 inserts a state",". ~","0","•","•","s, s_s , m t i h ~j+h , hl,ha->O, if and only if one of .",".","\"","|",".",".","the following condl~ons is met:","(i) n~ Middle-nodes (n'=n) and ¢(s) =~ IV, where !// spans ai+l ... aj (with the exception of string af.t+ 1 ... aft if ~(a) is included in qJ(s)) (see"]},{"title":"Figure 1),","paragraphs":["(ii) n~ Left-nodes, s=s' , hl=h2=O and ¢(s) ~ V/' , where ~: spans ai+t ... aj (with the exception of string aA+ 1 ... af if ~(a) is included in ¢(s)). Moreover', n' is t~ root of a (maximal) subtree z in a such thai z ~ ~, IV strictly includes if and every tree/~ A that has been adjoined to some node in the path from n' to n spans a string that is included in al ... ai (see Figure 2);","(iii) the symmetrical case of (ii).","a i +1 \"'\" af t X af ,+1 \"\" ai Figure 1. n\"","y a i +l..aflXafr+l. aj - Figure 2.","In order to present the computational complexity of Algorithm 1, some norms for TAGs are here in~ troduced. Let A be a set of nodes in some trees of a TAG G, we define","IGIA, k = ~ Ichildren(n)l k • nE .91",":The following result refers to the Random Access Machine model of computation. - 30 - Theorem 2 If some auxiliary structures (vector of lists) are used by Algorithm t for the bookkeeping of all states that correspond to completely analyzed auxiliary trees, a string can be recognized in"]},{"title":"O(nt.IAI.max{IGIN.M,I+IGIM,2})","paragraphs":["time, where M"]},{"title":"=Middle-nodes","paragraphs":["and N denotes the set of all nodes in the trees of G."]},{"title":"5. A Linguistic Example","paragraphs":["In order to gain a better understanding of Algorithm 1 and to emphasize the linguistic relevance of TAGs, we present a running example. In the following we assume the formal framework of X-bar Theory (Jackendoff, 1977). Given the sentence: (1) Gianni incontra Maria per caso","lit. Gianni meets Maria by chance we will propose here the following analysis (see Figure 4): (2) [ca [c' lip [NP Gianni] [r inc°ntrai [vp* [vP","[w e i [~ Maria]]] [pp per caso]]]]]] Note that the Verb"]},{"title":"incontra","paragraphs":["has been moved to the Inflection position. Therefore, the PP adjunction stretches the dependency between the Verb"]},{"title":"incontra","paragraphs":["and its Direct Object"]},{"title":"Maria.","paragraphs":["These cases may raise some difficulties in a context-free framework, because the lack of the head within its constituent makes the task of predicting the object(s) rather inefficient. Assume a TAG G=(VN,"]},{"title":"VZ, S, I, A),","paragraphs":["where VN={IP, r, vP, v', NP},"]},{"title":"V~:={Gianni, Maria, incontra,","paragraphs":["PP},I={o~} andA={fl} (see Figure 3; each node has been paired with an integer which will be used as its address). In order to simplify the computation, we have somewhat reduced the initial tree a and we have considered the constituent PP as a terminal symbol. In Figure 4 the whole analysis tree corresponding to (2) is reported. Let"]},{"title":"x(a)=5, z(fl)=13;","paragraphs":["from Definition 3 it follows that:"]},{"title":"F(5)=","paragraphs":["{[4, 5,"]},{"title":"left,","paragraphs":["5,"]},{"title":"right,","paragraphs":["-, -, -]},"]},{"title":"F(13)={[ll,","paragraphs":["13,"]},{"title":"left,","paragraphs":["11,"]},{"title":"right,-,-,-]}.","paragraphs":["A run of Algorithm 1 on sentence (1) is simplified in the following steps (only relevant steps are reported). First of all, the two anchors are recognized:","1) s1=[4, 5,"]},{"title":"left, 5, right,","paragraphs":["-, -, -] is inserted in tl.2 and s2=[ll, 13,"]},{"title":"left,","paragraphs":["13,"]},{"title":"right,","paragraphs":["-, -, -] is inserted in"]},{"title":"t3,4,","paragraphs":["by line 1 of the algorithm. Then, auxiliary tree fl is recognized in the following steps: 2) s3=[ll, 12,"]},{"title":"right,","paragraphs":["13,"]},{"title":"right,","paragraphs":["-, -, -] is inserted in t3. 4 and m is set to"]},{"title":"rm","paragraphs":["in state s2, by Case 2 of the"]},{"title":"move-dot-left","paragraphs":["procedure; 3) s4=[ll, 12,"]},{"title":"left,","paragraphs":["13,"]},{"title":"right,","paragraphs":["2, 3, -] is inserted in t2.4 and m is set to"]},{"title":"rm","paragraphs":["in state s3, by Case 3 of the"]},{"title":"left-expander","paragraphs":["procedure; 4) ss=[ll, 11,"]},{"title":"left,","paragraphs":["13,"]},{"title":"right,","paragraphs":["2, 3, -] is inserted in t2,4 and m is set to"]},{"title":"rm","paragraphs":["in state s4, by Case 3 of the"]},{"title":"move.dot-left","paragraphs":["procedure; 5) st=[11, 11,"]},{"title":"left,","paragraphs":["11,"]},{"title":"right,","paragraphs":["2, 3, -] is inserted in h,4 and m is set to"]},{"title":"lm","paragraphs":["in state Ss, by Case 3 of the"]},{"title":"move-dot-right","paragraphs":["procedure. Or: IP (I) (2) NP"]},{"title":"I","paragraphs":["O) Gianni r (4) incontra i (5) VP (6)"]},{"title":"I","paragraphs":["V' G) (8) e i NP"]},{"title":"I","paragraphs":["Mma (9) (1o) : VP 0;) (12) VP PP (13)","per caso Figure 3. IP NP I' Giar~ mcomra i VP VP PP per caso V' ¢i NP"]},{"title":"I","paragraphs":["Maria Figure 4. After the insertion of state s7--[4, 5,"]},{"title":"left, 6, left, -, -,","paragraphs":["-1 in tl,2 by Case 2 of the"]},{"title":"move-dot-right","paragraphs":["procedure, the VP node (6) is hypothesized by Case 1 (Step 2,"]},{"title":"via","paragraphs":["state s6) of the"]},{"title":"right-expander","paragraphs":["procedure with the insertion of state ss-[6, 6,"]},{"title":"left, 6, left,","paragraphs":["-, -, -1 in t2. 2. The whole recognition of node (6) takes place with the insertion of state s9;[6, 6,"]},{"title":"left, 6, right, -, -, -1","paragraphs":["in: t2,3. Then we have the following step: 6) s10=[6, 6,"]},{"title":"left, 6, right,","paragraphs":["-, -, -] is inserted in -31","t2,4, by the adjoiner procedure. The analysis proceeds working on tree a and reach-ing a final configuration in which state s~t=[1, 1, left, 1, right, -, -, -] belongs to to,4. 6, Discussion","Within the perspective of Lexicalized TAGs, known methods for TAGs recognition/parsing present some limitations: these methods behave in a left-to-right fashion (Schabes and Joshi, 1988) or they are purely bottom-up (Vijay-Shanker and Joshi, 1985, Harbusch, 1990), hence they cannot take advantage of anchor information in a direct way. The presented algorithm directly exploits both the advantages of lexicalization mentioned in the paper by Schabes and Joshi (1989), i.e. grammar filtering and bottom-up information. In fact, such an algorithm starts partial analyses from the anchor elements, directly selecting the relevant trees in the grammar, and then it proceeds in both directions, climbing to the roots of these trees and predicting the rest of the structures in a top-down fashion. These capabilities make the algorithm attractive from the perspective of linguistic information processing, even if it does not improve the worst-case time bounds of already known TAGs parsers.","The studied algorithm recognizes auxiliary trees without considering the substring dominated by the foot node, as is the case of the CYK-like algorithm in Vijay-Shanker and Joshi (1985). More precisely, Case 3 in the procedure Left-expander nondeterministically jumps over such a substring. Note that the alternative solution, which consists in waiting for possible analyses subsumed by the foot node, would prevent the algorithm from recognizing particular configurations, due to the bidirectional behaviour of the method (examples are left to the reader). On the contrary, Earley-like parsers for TAGs (Lang, 1990, Schabes, 1990) do care about substrings dominated by the foot node. However, these algorithms are forced to start at each foot node the recognition of all possible subtrees of the elementary trees whose roots can be the locus of an adjunction.","In this work, we have discussed a theoretical schema for the parser, in order to study its formal properties. In practical cases, such an algorithm could be considerably improved. For example, the above mentioned guess in Case 3 of the procedure Left-expander could take advantage of look-ahead techniques. So far, we have not addressed topics such as substitution or on-line recognition. Our algorithm can be easily modified in these directions, adopting the same proposals advanced in (Schabes and Joshi, 1988).","Finally, a parser for Lexicalized TAGs can be obtained from Algorithm 1. To this purpose, it suffices to store elements in IS into the recognition matrix T along with a list of pointers to those en-tries that caused such elements to be placed in the matrix. Using this additional information, it is not difficult to exhibit an algorithm for the construction of the desired parser(s). References","Harbusch, Karin, 1990. An Efficient Parsing Algorithm for TAGs. In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics. Pittsburgh, PA.","Jackendoff, Ray, 1977. X.bar Syntax: A Study of Phrase Structure. The M1T Press, Cambridge, MA.","Joshi, Aravind K., 1985. Tree Adjoining Grammars: How Much Context-Sensitivity Is Required to Provide Reasonable Structural Descriptions?. In: D. Dowty et al. (eds). Natural Language Parsing: Psychological, Computational and Theoretical Perspectives. Cambridge University Press, New York, NY.","Kroch, Anthony S. and Joshi, Aravind K., 1985. Linguistic Relevance of Tree Adjoining Grammars. Technical Report MS-CIS-85-18, Department of Computer and Information Science, University of Pennsylvania.","Lang, Bernard, 1990. The Systematic Construction of Earley Parsers: Application to the Production of O(n 6) Earley Parsers for Tree Adjoining Grammars. In Proceedings of the 1st International Workshop on Tree Adjoining Grammars. Dagstuhl Castle, F.R.G..","Satta, Giorgio, 1990. Aspetti computazionali della Teoria della Reggenza e del Legamento. Doctoral Dissertation, Univ'ersity of Padova, Italy.","Satta, Giorgio and Stock, Oliviero, 1989. Head-Driven Bidirectional Parsing: A Tabular Method. In Proceedings of the 1st International Workshop on Parsing Technologies. Pittsburgh, PA.","Schabes, Yves, 1990. Mathematical and Computational Aspects of Lexicalized Grammars. PhD Thesis, Department of Computer and Information Science, University of Pennsylvania.","Schabes, Yves; Abeill6, Anne and Joshi, Aravind K., 1988. Parsing Strategies for 'Lexicalized' Grammars: Application to Tree Adjoining Grammars. In Proceedings of the 12th International Conference on Computational Linguistics. Budapest, Hungary.","Schabes, Yves and Joshi, Aravind K., 1988. An Earley-Type Parsing Algorithm for Tree Adjoining Grammars. In Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics. Buffalo, NY.","Schabes, Yves and Joshi, Aravind K., 1989. The Relevance of Lexicalization to Parsing. In Proceedings of the 1st International Workshop on Parsing Technologies. Pittsburgh, PA. To also appear under the title: Parsing with Lexicalized Tree Adjoining Grammar. In: M. Tomita (ed.). Current Issues in Parsing Technologies. The MIT Press.","Vijay-Shanker, K. and Joshi, Aravind K., 1985. Some Computational Properties of Tree Adjoining Grammars. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics. Chicago, IL. - 32 -"]}]}