{"sections":[{"title":"Semantic Information Preprocessing for Natural Language Interfaces to Databases","paragraphs":["Milan Mosny","Simon Fraser University","Burnaby, BC VhA 1S6,","Canada mosny@cs.sfu.ca"]},{"title":"Abstract","paragraphs":["An approach is described for supplying selectional restrictions to parsers in natural language interfaces (NLIs) to databases by extracting the selectional restrictions from semantic descriptions of those NLIs. Automating the process of finding selectional restrictions reduces NLI development time and may avoid errors introduced by hand-coding selectional restrictions. 1 Introduction An approach is described for supplying selectional restrictions to parsers in natural language interfaces (NLIs) to databases. The work is based on Linguistic Domain Theories (LDTs) (Rayner, 1993). In our approach, we propose a restricted version of LDTs (RLDTs), that can be normalized and in normalized form used to construct selectional restrictions. We assume that semantic description of NLIs is described by such an RLDT.","The outline of the paper is as follows. Section 2 provides a brief summary of original LDTs, illustrates how Abductive Equivalential Translation (AET) (Rayner, 1993) can use them at run-time, and describes RLDTs. Sections 3 and 4 describe off-line processes - the normalization process and the extraction of selectional restrictions from normalized RLDTs respectively. Section 5 contains discussion, including related and future work. 2 LDT, AET and RLDT LDT and AET. LDT was introduced for a system, where input is a logical formula, whose predicates approximately correspond to the content words of the input utterance in natural language (lexical predicates). Output is a logical formula, consisting of predicates meaningful to the database engine (database predicates). AET provides a formalism for describing how a formula consisting of lexical predicates can be tranlsated into formula consisting of database predicates. The information used in the translation process is an LDT. A theory r contains horn clauses"]},{"title":"v(p~ A... A P,, --* Q)","paragraphs":["or universal conditional equivalences"]},{"title":"v(P1 .̂.. ̂P. ~ (RI .̂.. ̂Rz -= F))","paragraphs":["or existential equivalences V((3Xl.- .Xm.P) -- F) where Pi, Ri denote atomic formulas, Q denotes a literal, F denotes a formula and V denotes universal closure. The LDT also contains functional relationships that are used for simplifications of the translated formulas and assumption declarations. Given a formula Fting consisting of lexical predicates and an LDT, AET tries to find a set of permissible assumptions A and a formula Fab consisting of the database predicates such that F u A =~ V(Fti,g = Fab) The translation of Fzi,g is done one predicate at a time. For each predicate in the formula Fting, there is a so-called conjunctive context that consists of conjuncts occurring together with the predicate in Fting, meaning postulates in the theory P, and the information stored in the database. Given an LDT, this conjunctive context determines how the predicate will be translated by AET.","As an example, suppose that the lexical representation of the sentence Is there a student who takes cmpt710 or cmpt7207 is Fzin~:",":iX, E, Y, Y1 .student(X) A"]},{"title":"(take(E, X, Y) ̂unknown(Y, cmptT10) V take(E, X, Y, ) ̂unknown(Y~, erupt720))","paragraphs":["Suppose that the theory r consists of axioms: VX.siudent(X) - db_student(X) (1)"]},{"title":"vx, E, Y, S.db_course(Y, S) ̂db_~tudent(X) (2)","paragraphs":["--~ (take(E, X, Y) =_ db_take(E, X, Y))"]},{"title":"VX, S.acourse(S) --~ (3) (unknown(X, S) =-\" db_course( X, S) )","paragraphs":["VE, X, Y.db_take(E, X, Y) --* take(E, X, Y) (4)"]},{"title":"314","paragraphs":["where"]},{"title":"student, take","paragraphs":["and"]},{"title":"unknown","paragraphs":["are lexical predicates and"]},{"title":"db_student, rib_course, db_take","paragraphs":["are database predicates 1. Also suppose, that the LDT declares as an assumption"]},{"title":"aeourse(X),","paragraphs":["which can be read as \"X denotes a course\". Part of the conjunctive context associated with formula"]},{"title":"take(E, X, Y)","paragraphs":["in Ftlag is a formula (5)."]},{"title":"student(X) ̂unknown(Y, crept710) (5)","paragraphs":["From (1) and (3) of the theory F it follows that (5) implies the formula (6):"]},{"title":"db_student(X) A db_course(Y, crept710)","paragraphs":["(6) According to the translation rules of AET, axiom (2), and a logical consequence of a conjunctive context (6), the"]},{"title":"formula take( E, X, Y)","paragraphs":["can be translated into formula (7)"]},{"title":"db2ake( E, X, Y)","paragraphs":["(7) Formulas"]},{"title":"student(X), take(E, X, Y1), unknown(Y, cmpt710)","paragraphs":["and"]},{"title":"unknown(Yl, cmpt720)","paragraphs":["are translated similarly. Assuming"]},{"title":"crept710","paragraphs":["and"]},{"title":"crept720","paragraphs":["are courses, the input Fsi,g can be rewritten into Fdb shown below."]},{"title":"3X, E, Y, Y1 .db~tudent(X) ̂( db_take( E, X, Y) A db_course(Y, crept710) V rib_take(E, X, Yz ) A db_course(Y1, crept720))","paragraphs":["So we can claim that Fab and"]},{"title":"Fzin9","paragraphs":["are equivalent in the theory F under an assumption that"]},{"title":"crept710","paragraphs":["and"]},{"title":"crept720","paragraphs":["are courses. RLDT. We shall constrain the expressive power of the LDT to suit tractability and efficiency requirements.","We assume that the input is a logical formula, whose predicates are input predicates. We assume that input predicates are not only lexical predicates, but also unresolved predicates used for, e.g., compound nominals (Alshawi, 1992), or for unknown words, as was demonstrated in the example above, or synonymous predicates that allow us to represent two or more different words with only one symbol.","The output will be a logical formula consisting of output predicates. We do not suppose that the output formula contains pure database predicates. However, we allow further translation of the output formula into database formulae using only existential conditional equivalences. The process can be implemented very efficiently, and does not affect selectional restrictions of the input language.","We assume that each atomic formula with input predicates can be translated into an atomic formula with output predicates. An RLDT therefore also aThe predicate"]},{"title":"unknown","paragraphs":["will be discussed in the next section. contains a dictionary of atomic formulas that specifies which input atomic formulas can be translated into which output atomic formulas.","Existential equivalences in KLDT's logic will not be allowed. We also assume that F in the universal conditional equivalences is a conjunction of atomic formulas rather than arbitrary formula.","We demand that an RLDT be nonrecursive. Informally RLDT nonrecursivness means that for any set of facts A, if there is a Prolog-like derivation of an atomic formula F in the theory F U A, then there is a Prolog-like derivation of F without recursive calls."]},{"title":"3 The Normalization Process","paragraphs":["Our basic idea is to preproeess the semantic information of KLDT to create patterns of possible conjunctive contexts for each lexical predicate. The result of the preprocessing is a"]},{"title":"normalized","paragraphs":["KLDT: the collection of the lexical predicates, their meanings in terms of the database, and the patterns of the conjunctive contexts.","First we introduce the term"]},{"title":"(Nontrivial) Normal Conditional Equivalence with respect to an","paragraphs":["RLDT T ((N)NCE(T)). Definition: Let T be an RLDT and F be a logical part of T. The quadruple (A, C,"]},{"title":"Fim,,t, Fo,,put)","paragraphs":["is NCE(T) iff C is a conjunction of input atomic formulas of T, A is a conjunction of assumptions of T, and formulas","V(A ̂C -. (F~.p., = Eo.,p.,)) V(A ̂Fo.,p., -* E~.p.,) are logical consequences of the theory F (we shall refer to the last condition as soundness of the NCE(T)). We shall call the quadruple"]},{"title":"(A, C, Fi,put, Foutv,,t) nontrivial","paragraphs":["NCE(T) (NNCE(T)) iff formula C A A does not imply truth of"]},{"title":"Foutp,,t","paragraphs":["in the theory F. Informally it means that"]},{"title":"Fi,p,,t","paragraphs":["can be rewritten to"]},{"title":"Fo,,tp,t","paragraphs":["if its conjunctive context implies A and does not imply the negation of C. (A, C) thus can be viewed as a pattern of conjunctive contexts, that justifies translation of"]},{"title":"Finput","paragraphs":["to"]},{"title":"Foutput.","paragraphs":["We allow RLDTs to form theory hierarchies, where parent theories can use results of their children's normalization process as their own logical part.","Given an I~LDT T, for each pair consisting of the ground lexical atomic formula"]},{"title":"Fi,put","paragraphs":["and the ground database atomic formula"]},{"title":"Fo,,tput","paragraphs":["from the dictionary of T, we find the set S of conditions (A, C) such that (A,"]},{"title":"C, Fi,,pu,, Fo,,p,,)","paragraphs":["is NCE(T). We shall call the set of all such NCE(T)s"]},{"title":"a normalized","paragraphs":["R.LDT. If"]},{"title":"Fi,put","paragraphs":["and"]},{"title":"Fo,,tp,t","paragraphs":["contain constants that do not occur in the logic of RLDT, the generalization rule of FOL can be used to derive more general results by replacing the constants by unique variables."]},{"title":"315","paragraphs":["If the T does not contain negative horn clauses of the form"]},{"title":"P ---* notQ","paragraphs":["then the following completeness","property can be proven: If (A1, C1, Fi,e,~, Fox,put) is NNCE(T) and S is a resulting set for the pair"]},{"title":"Finput, Foutp~t","paragraphs":["then there are conditions (A, C) in S, such that"]},{"title":"AAC","paragraphs":["is weaker or equivalent to Ax A C1. The normalization process itself is based on SLDresolution(Lloyd, 1987) which we have chosen be-cause it is fast, sound and complete but still provides enough reasoning power.","Using the example from the previous section, the normalization algorithm when given the pairs"]},{"title":"(student(a), db_student( a ) ), ( unknown( a, b ), db_course(a, b))","paragraphs":["and"]},{"title":"(take(e, a, b), db_take(e, a, b))","paragraphs":["will produce the results"]},{"title":"{(true, true)}, {(aeour,e(b), true)} and {(acourse(X), student(a) A unknown(b,","paragraphs":["X)} respectively."]},{"title":"4 The Construction of Selectional Restrictions","paragraphs":["The"]},{"title":"normalized","paragraphs":["RLDT is used to construct selectional restrictions.","We assign the tags \"thing\" or \"attribute\" to argument positions of the lexical predicates according to what kind of restriction the predicate imposes on the referent at its argument position. If the predicate is a noun or the referent refers to an event, we assign the tag \"thing\". If the predicate explicitly specifies that the referent has some attribute - e.g. predicate"]},{"title":"big(X)","paragraphs":["specifies the size of the thing referenced by X and predicate"]},{"title":"take(_, X,_)","paragraphs":["specifies that the person referenced by X takes something - then we tag the argument position with \"attribute\". The"]},{"title":"normalized","paragraphs":["RLDT allows us to compute which \"things\" can be combined with which \"attributes\". That is, we can determine which words can be modified or complemented by which other words.","We assume that the"]},{"title":"normalized","paragraphs":["RLDT has certain properties. Every NCE(T) that describes a translation of an \"attribute\" must also define a \"thing\" that constrains the same referent, e.g. the NCE(T)"]},{"title":"(true, person(X) A drives(E,X,Y), big(Y), db_big_car(Y))","paragraphs":["for translation of the predicate"]},{"title":"big(Y)","paragraphs":["does not fulfil the requirement but NCE(T)"]},{"title":"(true, car(Y), big(Y), db_big_car(Y) )","paragraphs":["does. We also assume that if a certain \"thing\" does not","occur in any of the NCE(T)s that translates an"]},{"title":"\"at-","paragraphs":["tribute\" then the \"thing\" cannot be combined with the \"attribute\".","Using the example above and the assignments"]},{"title":"student(X) X","paragraphs":["is a \"thing\""]},{"title":"unknown(X,S) X","paragraphs":["is a \"thing\""]},{"title":"take(E, X, Y) E","paragraphs":["is a \"thing\", X and Y are \"attributes\"","we can infer that"]},{"title":"student(X)","paragraphs":["can be combined with attribute"]},{"title":"take(_, X,_)","paragraphs":["but cannot have an attribute"]},{"title":"take(_,_,X).","paragraphs":["To simplify results, we divide \"attributes\" into equivalence classes where two \"attributes\" are equivalent if both attributes are associated with the same set of \"things\" that the attributes can be combined with. We then assign a set of representatives from these classes to \"things\".","To be able to produce more precise results, we distinguish between two \"attributes\" that describe the same argument position of the same predicate according to the \"thing\" in the other \"attribute\" position of the predicate, when needed. Consider for example the preposition \"on\" as used in the phrases \"on the table\" or \"on Monday\". We handle the first argument position of a predicate"]},{"title":"on(X,Y)","paragraphs":["associated with the condition"]},{"title":"table(Y)","paragraphs":["as a different \"attribute\" as compared to the condition"]},{"title":"monday(Y). 5 Discussion","paragraphs":["Automating the process of finding selectional restrictions reduces NLI development time and may avoid errors introduced by hand-coding selectional restrictions. Althcugh the preprocessing is computationally intensive, it is done off-line during the delevopment of the NLI.","A similar approach was proposed in (Alshawi, 1992) but a different method was suggested. (Alshawi, 1992) derives selectional restrictions from the types associated with the database predicates, whereas our approach uses only the constraints that the RLDT imposes on the input language.","Future work will explore other uses of"]},{"title":"normalized","paragraphs":["RLDTs: to construct a sophisticated help system, to lexicalize some small database domains, and to develop more complex lexical entries. We shall also consider the possible uses of our work in general NLP. Acknowledgments The author would like to thank Fred Popowich and Dan Fass for their valuable discussion and suggestions. This work was partially supported by the Natural Sciences and Engineering Research Council of Canada under research grant OGP0041910, by the Institute for Robotics and Intelligent Systems, and by Faculty of Applied Sciences Graduate Fellowship at Simon Fr;,.ser University. References Alshawi, Hiyan, ed. 1992."]},{"title":"The Core Language En- gine.","paragraphs":["Cambridge, Massachusetts: The MIT Press. Lloyd, John W., 1987."]},{"title":"Foundations of Logic Pro- gramming,","paragraphs":["Second, Extended Edition, Springer-Verlag, New York. Rayner, Manny, 1993."]},{"title":"Abductive Equivalentiai Translation and its application to Natural Language Database Interfacing.","paragraphs":["Ph.D. Thesis, Royal Institute of Technology, Stockholm, Sweden."]},{"title":"316","paragraphs":[]}]}
