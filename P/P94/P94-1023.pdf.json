{"sections":[{"title":"ON DETERMINING THE CONSISTENCY OF PARTIAL DESCRIPTIONS OF TREES Thomas L. Cornell Cognitive Science Program University of Arizona Tucson, AZ 85721 cornell@ccit.arizona.edu Abstract 1","paragraphs":["We examine the consistency problem for descriptions of trees based on remote dominance, and present a consistency-checking algorithm which is polynomial in the number of nodes in the description, despite disjunctions inherent in the theory of trees. The resulting algorithm allows for descriptions which go beyond sets of atomic formulas to allow certain types of disjunction and negation."]},{"title":"INTRODUCTION","paragraphs":["In Marcus, Hindle & Fleck (1983), the authors proposed an approach to syntactic tree structures which took the primary structural relation to be remote dominance rather than immediate dominance. Recently, researchers have shown a revived interest in variants of Marcus et al.'s D-Theory, most likely due to the availability of approaches and techniques developed in the study of feature structures and their underlying logics. For example, both Rogers & Vijay-Shanker"]},{"title":"(1992)","paragraphs":["and Cornell"]},{"title":"(1992)","paragraphs":["present formal treatments of many notions which Marcus et al."]},{"title":"(1983)","paragraphs":["treated only informally and incompletely. Furthermore, work on the psycholinguistic implications of this approach has continued apace (Weinberg 1988; Gorrell 1991; Marcus & Hindle 1990), making all the more necessary sustained foundational work in the theory of description-based tree-building applications (parsers, generators, etc.)","This paper addresses one particular problem that arises in this approach to tree building. As with feature-structures, the essential operation here is the combination of two collections of partial information about the syntactic structure of an expression. It may happen that the two","1 Many thanks to Dick Oehrle, Ed Stabler, Drew Moshier and Mark 3ohnson for comments, discussion and encouragement. Theirs the gratitude, mine the fault. collections to be combined contain contradictory information. For example one might contain the assertion that \"node 7 dominates node 12\" while the other claims that \"node 12 precedes node 7\". No tree structure can satisfy both these constraints. The operation of description combination is thus not simple set union, but, like unification, involves taking a least upper bound in a semi-lattice where lub's are not everywhere defined.","Both Rogers & Vijay-Shanker (1992) and Cornell (1992) propose to solve the D-Theoretic consistency problem by using essentially Tableau-based approaches. This can lead to combinatorial explosion in the face of disjunctions inherent in the theory of trees. But as it happens, proof techniques designed to handle general disjunctions are more powerful than we need; the disjunctions that arise from the theory of trees are of a restricted kind which can be handled by strictly polynomial means. We will see that we can efficiently handle richer notions of description than those in the \"classical\" D-Theory of Marcus, et al. (1983)."]},{"title":"D-THEORYANDTREETHEORY DESCRIPTION LANGUAGE","paragraphs":["We will make use of the following description language ,,~. Define the set of basic relation names, R, as: b --\"below\" (i.e., dominated-by) d -- \"dominates\" e -- \"equals\" f --\"follows\" (i.e., preceded-by) p -- \"precedes\" We define an algebra on relation names as follows."]},{"title":"($1 V $2)(x,y)","paragraphs":["=def the collection of relation names in either"]},{"title":"$1","paragraphs":["or"]},{"title":"S2. (S1 A $2)(x,y)","paragraphs":["=def the collection of relation names in both"]},{"title":"$1","paragraphs":["and"]},{"title":"$2. S'(xoI)","paragraphs":["--def the collection of relation names"]},{"title":"163","paragraphs":["not in S. We then define the full set of compound relation name expressions R* as the closure of the basic relation names under A, V and '. A"]},{"title":"formula","paragraphs":["of is then an element of R* applied to a pair of node names. We will often refer to the compound relation name expression in a formula"]},{"title":"S(x,31 )","paragraphs":["as a"]},{"title":"constraint on the pair x, 31.","paragraphs":["Semantically, we treat"]},{"title":"S(x,31 )","paragraphs":["as satisfiable if we can assign the denotata of the pair x, 31 to at least one of the relations denoted by members of S. On this semantics, if"]},{"title":"S(x,31 )","paragraphs":["is satisfiable and S ~< T, then"]},{"title":"T(x,31 )","paragraphs":["is satisfiable as well. Clearly the empty constraint (x,31) is never satisfiable. (Atoms of the form"]},{"title":"e(x,31 )","paragraphs":["are satisfiable if and only if x and 31 denote identical members of the domain of discourse. Atoms of the form b(x,31) and f(x,31) are to be considered equivalent to"]},{"title":"d(31,x )","paragraphs":["and"]},{"title":"p(31,x),","paragraphs":["respectively.)"]},{"title":"A description","paragraphs":["is a finite set of formulas. If a description contains only formulas with a basic relation name, we will call it"]},{"title":"classical,","paragraphs":["since this is the type of description considered in Marcus et al."]},{"title":"(1983). AXIOMS","paragraphs":["Note that such structures are not guaranteed to be trees. Therefore we make use of the following fragment of an axiomatization of tree structures, which we will assume in the background of all that follows, and formalize in the next section."]},{"title":"Strictness.","paragraphs":["Dominance and precedence are strict partial orders, i.e., transitive and irreflexive relations."]},{"title":"Equality.","paragraphs":["We assume that equality is reflexive, and that we can freely substitute equals for equals."]},{"title":"Exhaustiveness.","paragraphs":["Every pair of nodes in a tree stand in at least one of the five possible relations. I.e. R(x,31 ) for all x and 31."]},{"title":"Inheritance.","paragraphs":["All nodes inherit the precedence properties of their ancestors. So if"]},{"title":"p(x,31 )","paragraphs":["and"]},{"title":"d(31,z),","paragraphs":["then"]},{"title":"p(x,z)","paragraphs":["as well. A number of familiar properties of trees follow from the above system. Inheritance assures both the non-tangling of tree branches and the impossibility of upward branching ('V-shaped') configurations. Inheritance, Transitivity, Substitution of equals and Exhaustiveness jointly derive the property of"]},{"title":"Exclusiueness,","paragraphs":["which states that every pair of nodes is related in"]},{"title":"at most","paragraphs":["one way. (Note that it is Exclusiveness which assures the soundess of our use of A.) A less familiar property, which we will make some use of, is roughly parallel to Inheritance;"]},{"title":"Upwards Inheritance","paragraphs":["states that if x dominates 31 and 31 precedes (follows) z, then x dominates or precedes (follows) z.","Note that this system is not meant to be an axiomatic"]},{"title":"definition","paragraphs":["of trees; it lacks a Rootedness condition, and it allows infinite and densely ordered structures. It is specifically adapted to the"]},{"title":"satisfiabilit31","paragraphs":["problem, rather than the"]},{"title":"oalidit31","paragraphs":["problem. It is relatively straightforward to show that, from any finite atomic dE-description satisfying these conditions, we can construct a finite tree or a precedence ordered finite forest of finite trees (which can be extended to a finite tree by the addition of a root node). So this system is complete as far as satisfiability is concerned. Briefly, if a set of formulas satisfies all of the above constraints, then we can (1) construct a new description over the quotient node-space modulo e; (2) list the dominance chains; (3) add a root if necessary; (4) noting that the dominance maximal elements under the root must be totally precedence ordered (they must be ordered and they cannot be dominance ordered or they would not be maximal), we number them accordingly; (5) apply the same procedure to the dominance ideals generated by each of the root's daughters. From the resulting numbering we can construct a \"tree domain\" straightforwardly. The Inheritance property assures us that dominance chains are non-tangled, so that the ideal generatred by any node will be disjoint from the ideal generated by any node precedence-ordered with respect to the first. Therefore no node will receive two numbers, and, by Exhaustiveness, every node will receive a number."]},{"title":"DEDUCTION WITH DESCRIPTIONS","paragraphs":["There is a strong formal parallel among the axioms of Transitivity, Substitution of Equals, and Inheritance: each allows us to reason from a pair of atomic formulas to a single atomic formula. Thus they allow us to reason from classical descriptions to (slightly larger) classical descriptions. Let us refer to these axioms as"]},{"title":"9enerators.","paragraphs":["The reason for adopting dE as a description language, rather than the simpler language of Marcus et al. (1983), is that we can now treat the No Upward Branching property (\"if x and z both dominate 31 then x dominates z or z dominates x or they are equal,\") and the Upwards Inheritance property as generators. They allow us to reason from pairs of atomic formulas (e.g.,"]},{"title":"d(x,31 )","paragraphs":["and P(31,z)) to compound formulas (e.g.,"]},{"title":"dp(x,z)).","paragraphs":["This means that we can express the consequences of any pair of atomic"]},{"title":"164","paragraphs":["b(x,y) b(x,z) d(x,y) bde(x,z) e(x,y) b(x,z) f(x,y) bf(x,z) p(x,y) bp(x,z) R(x,z)"]},{"title":"]","paragraphs":["f(x,z) p(x,z) b(x,z) fix,z) p(x,z) d(x,z) df(x,z) ' dp(x,z)"]},{"title":"~(x,z) fix,z) i p(x,z)","paragraphs":["f(x,z) f(x,z) R(x,z)"]},{"title":"p(x,z) R(x,z)","paragraphs":["Figure 1. Generator Table. formulas as a formula of d~, though possibly a compound formula. They are exhibited in Figure 1. Cells corresponding to axioms in the theory are boxed. For doing formal deductions we will employ a sequent calculus adapted to our description language ~. We assume that sequents are pairs of finite sets of formulas, and we can make the further restriction that formulas on the right of the sequent arrow (\"succedents\") contain at most a single member. The axioms of the calculus we employ are exhibited in Figure 2, and the connective rules in Figure 3. Structural Axioms: F,A --. A Generator Axioms: F, Sl(x,y),S2(y,z) --- S3(x,z)"]},{"title":"for all instances of the generators","paragraphs":["Exhaustiveness: --. R(x,y)"]},{"title":"for all x, y","paragraphs":["Figure 2. D-The0ry Axioms. A sequent [F --, A] is interpreted as an implication from conjunctions to disjunctions: if everything in F is true, then something in A must be true. It follows that [--*A] is invariably true, and [F--,] is invariably false. A sequent calculus"]},{"title":"proof","paragraphs":["is a tree (written right side up, with its root on the bottom) labeled with sequents. The theorem to be proved labels its root, the leaves are labeled with axioms, and all the local subtrees must be accepted by some inference rule. A proof that a description F0 is inconsistent is a proof of the sequent [F0--*]. Note that r--, (x,~) F--, is a valid inference, essentially since (x,y) and the empty succedent both express the empty disjunction. RA LV","r, Sl(x,y) -. A LA ($2 ~< S1)"]},{"title":"F, S2(x,y) --, A","paragraphs":["F --* Sl(x,y) r --* S2(x,y) F --* (SIA S2)(x,y) F, Sl(x,y) -, A r, SZ(x.y) --, A r,(sa v se)(x,y) --, z~","r -. Sa(x,y) Rv"]},{"title":"($2 <<. S1 )","paragraphs":["r -. S2(x,y) F --* S(x,y)","L' r,s'~,y)~ r,s(x,y) -~ R' F -, S'(x,y) Figure 3. D-Theory Inference Rules."]},{"title":"TWO ALGORITHMS","paragraphs":["Suppose we are given an input description F0 to check for satisfiability. If it is unsatisfiable, then it"]},{"title":"contradicts","paragraphs":["one of the axioms of the tree theory: Exhaustiveness, Reflexivity of Equals, lrreflexivity of Dominance and Precedence, and the Generators. A complete consistency checker must be able to exhaust the consequences of these axioms for F0, monitoring for the false formula (x,~/).","Both algorithms take as input a description and an integer indicating the number of node-names constrained by the description. In the Prolog implementations that follow, the description is expected to be a list of constraints"]},{"title":"in normal order,","paragraphs":["that is, with the first argument lexicographically less than or equal to the second. Thus, assuming we are using integers as node names, the normal order form of d(2,1) will be b(1,2). Furthermore, the description is assumed to be sorted by its node-pairs. This will allow us to use efficient ordered-set manipulations.","For any given set of nodes of size N, we can construct a description which is a filter for violations of Reflexivity, lrreflexivity and Exhaustiveness. We construct"]},{"title":"F N","paragraphs":["to contain for every pair of nodes"]},{"title":"x,, xj, i,j <~ N, e(x,,xj)","paragraphs":["if i =j, and"]},{"title":"e'(x,xi)","paragraphs":["(i.e.,"]},{"title":"bdfp(x,xi))","paragraphs":["if"]},{"title":"i#j.","paragraphs":["We can"]},{"title":"165 e(1,3),d(1,2),p(2,3)--,dp(l,3) d(l,2),p(2,3),e(1,3)~e(l,3) RA e(1,3), d(1,2),p(2,3) ~ (1,3) e(1,3), d(l,2), p(2,3) ---, V","paragraphs":["LV Figure 4. {d(1,3), e(1,3), p(2,3)} is Inconsistent."]},{"title":"A","paragraphs":["e(1,3), d(1,2),p(2,3) --. e(1,3), p(1,2),p(2,3) --.","e(1,3), dp(1,2), p(2,3) LV"]},{"title":"f(1,3),d(1,2),p(2,3)~ f(1,3),p(1,2),p(2,3)~","paragraphs":["Lv f(1,3), dp(1,2), p(2,3) --, el(l,3), dp(1,2), p(2,3) --, Figure 5. {ef(1,3),dp(1,2), p(2,3)} is Inconsistent (A RA-LV Proof). determine that a description F0 violates either Reflexivity, lrreflexivity or Exhaustiveness simply by taking its pointwise meet F0 I\"1"]},{"title":"FN .2","paragraphs":["If a description is in violation of the Exhaustiveness condition, then it contains some formula"]},{"title":"S(x,21)","paragraphs":["with some part of S not given in R*. In that case, taking its meet with anything ~< R(x,21) will prune away the offending part. Similarly, if a constraint on a reflexive pair of nodes"]},{"title":"S(x,x)","paragraphs":["fails to have eE S, then taking its meet with"]},{"title":"e(x,x)","paragraphs":["will yield"]},{"title":"(x,x).","paragraphs":["Finally, taking the meet of"]},{"title":"S(x,y), x # 2t,","paragraphs":["with"]},{"title":"e'(x,21)","paragraphs":["will yield"]},{"title":"(x,21)","paragraphs":["if S = e; in arty case it will have the useful effect of pruning e out of S. Therefore both algorithms begin by constructing"]},{"title":"F N","paragraphs":["and then taking its meet with the input description. This has the extra side effect that any pair of nodes x and 21 not explicitly constrained in the input will now be explicitly constrained."]},{"title":"EXTEND : TOP-DOWN BACKTRACKING SEARCH FOR CONSISTENT MAXIMAL EXTENSIONS","paragraphs":["Given that we have begun by taking F0 I-I"]},{"title":"F N,","paragraphs":["we have only the generators left to check F0 against. We can think of the generator table as defining a function from pairs of atomic formulas to consequences. To use it we must first have atomic formulas. Def'n: A description r' is a"]},{"title":"maximal extension","paragraphs":["of a description F if, for every formula"]},{"title":"S(x,y)","paragraphs":["in","2 We can assume that any pair of nodes x, y not explicitly constrained in the input is implicitly constrained by R(x,y). Of course, (RAe')= e', so this assumption just amounts to setting unmentioned pairs of (distinct) nodes to e'(x,y)."]},{"title":"FRFN,","paragraphs":["r' contains"]},{"title":"s(x,y)","paragraphs":["for some"]},{"title":"sES.","paragraphs":["An obvious solution is to enumerate the maximal extensions of F0 F'I"]},{"title":"F N","paragraphs":["and feed them to the generators. If any such extension passes the generators, then it is satisfiable, and therefore it is a witness to the satisfiability of F0. If the extension is unsatisfiable, then it must violate at least one of the generators. Because a maximal extension is a total assignment of node-pairs to relations, a single application of a well-chosen generator will suffice to derive a contradiction. And so a single pass through the complete set of applicable generators should be sufficient to decide if a given maximal extension is consistent.","Thus, if the input description F0 is inconsistent, then there is a proof of F0--, in which every branch of the proof ends in a sub-proof like that in Figure 4. There we have the simple description"]},{"title":"{d(1,2),e(1,3),p(2,3)},","paragraphs":["which gives us dp(1,3), by a generator (Upwards Inheritance, in this case), and e(1,3), by a structural axiom. Combining these by an invocation of RA we get the false formula (1,3). The roots of these sub-proofs can be combined using LV until we eventually build up the input description on the left, proving F0-', as in Figure 5.","The following fragment of a Prolog implementation of max_extension/3 can be seen as implementing a backwards chaining search for such a \"RA-LV\" proof. The input to both"]},{"title":"extend","paragraphs":["and to"]},{"title":"close","paragraphs":["(see below, next section) is assumed to be an ~-description together with an integer giving the number of node-names subject to the description. The node-count is used to construct the appropriate"]},{"title":"F N","paragraphs":["for this description. Note"]},{"title":"166","paragraphs":["that, aside from implementing pointwise /-1, merge descs/3 checks for the derivation of an empty constraint, and fails if that happens. The real work is then done by extend/3, which is a recursion on an Agenda. The agenda is initialized to the input description. As individual constraints are narrowed, they are added to the agenda so as to implement constraint propagation.","max_axtension( DO, N, Extension ) :- it reflexive_rule( N, Filter_N ), merge._descs( DO, Filter_N, D1 ), Agenda = D1, extend( Agenda, D1, Extension ).","extend( [], X, X ).","extend( [COICs], D0, X ) :- consequences( CO, D0, Conseqs ), meet_rule( Conseqs, DO, D1, NewCons ), merge_descs( NewCons, Cs, Agenda1 ), extend( Agenda1, D1, X ). Meet_rule/4, in the second clause of"]},{"title":"extend~3,","paragraphs":["differs from merge_descs/3 only in (a) sorting its first argument and (b) deriving both the merged description (D1) and a list of those consequences which actually had some effect on DO. Both merge_descs/3 and meet_rule/'[ are based on routines for ordered set union from O'Keefe (1990). The main difference is that ordering is defined on the node-pairs of the constraint, rather than on the term expressing the constraint as a whole; equality is defined so that two constraints are equal if they constrain the same node pair, and if two formulas are 'equal' in this sense, then the output contains the meet of their respective relation names expressions. The truly new consequences derived by meet_rule/4 are then added to the remaining agenda (Cs) with another call to merge_descs/3. (If NewCons were merely appended to Cs, we could have two constraints on the same pair of nodes in the agenda at once, either of which may be less tightly constrained than the result of merging the two instances.)","Extend/3 thus both consumes items off the agenda (CO) and adds new items (NewCons). However, each new consequence, if it is truly novel, represents the narrowing of a constraint; since each pair starts with a maximum of four options, clearly we will eventually run out of options to remove; NewCons will be empty, the remaining agenda will eventually be consumed, and the program will halt.","The core of extend/3 is consequences/3, which determines for any given constraint what consequences it has when paired with each of the constraints in the description. Consequences/3 has two clauses; the first handles compound formulas, while the second handles atomic formulas. The second clause of consequences/3 invokes the Splitting Rule, which implements LV.","Note that, instead of exhausting the consequences of the Splitting Rule and then applying the Generator Rule, we apply the Generator Rule whenever we can. This is because it can act to prune away options from its consequents, thus minimizing the combinatorial explosion lurking behind the Splitting Rule. Furthermore, if an application of the Generator Rule does lead to the discovery of an inconsistency, then the program backtracks to its last application of the Splitting Rule, in effect pruning away from its search tree all further consequences of its inconsistent choice.","consequences( C. _D, Consequences ) :- compound_formula( C ), splittingrule( C, Consequences ).","consequences( C, D, Consequences ) :- atomic_formula( C ), generator_rule( D, C, Consequences ). atomic_formula([_]:(_~_) ). compound_formula(L,_L.]:(_,_) ).","splitting_rule( C, [Assumption] ) :- C = Rels:Nodes, member( R, Rels ), Assumption = [R]:Nodes. The heart of consequences/3 is the Generator Rule, implemented as generator_rule/3. It scans the current description for formulas which form a connected pair with its second argument. Note that in all our examples, we have carefully presented inputs to the generators as Sx(x,3),"]},{"title":"Sz(y,z).","paragraphs":["Such a combination can be looked up directly in the generator table. However, note that St(x,y),"]},{"title":"S2(z,y)","paragraphs":["is no less a connected pair. In order to match it to the generator table, though, we need to invert the second member, giving Sz'l(y,z). This is done by connected order/4, which succeeds, returning the connected form of the formulas, if they have a connected form, and fails otherwise. If it succeeds, then there is art entry in the generator table which gives the consequence of that connected pair. This consequence (XZ) is then placed in normal order (C3), and added to the output list of consequences. If"]},{"title":"C2","paragraphs":["is an unconnected atom, or a compound formula, it is skipped. Note that skipping compound formulas does not affect the 167 completeness of the algorithm. Every agenda item leads a dual life: as an agenda item, and as a member of the current description. The ignored compound formula will eventually be subjected to the Splitting Rule, the result being placed on the agenda. It will then eventually be paired with C2's entry in the description by the Generator Rule. The only difference will be in which formula is the left antecedent and which the right; but that doesn't matter, since they'll be converted to connected form in any case, and their result will be converted to normal order. 3","generator_rule( ~, _C, [1 ).","generator_rule( [C21Rest], C1, [C3lConseqs] ) :- atomic._formula( C2 ), connected_order( C1, C2, XY, YZ ), gen( XY, YZ, XZ ), normal_order( XZ, C3 ), generator_rule( Rest, C1, Conseqs ).","generator_rule( [C21Rest], C1, Conseqs ) :- atomic_formula( C2 ), \\+ connected_order( C1, C2 .... ), generator_rule( Rest, C1, Conseqs ).","generator__rule( [C2JRest], C1, Conseqs ) :- compound_formula( C2 ), generator_rule( Rest, C1, Conseqs ). Every rule applied in this procedure is based on a rule in the associated sequent calculus. The Splitting Rule is just LV; the Meet Rule is RA; and the Generator Rule is just the application of an axiom. So there can be little doubt that the algorithm is a sound implementation of a search for a LV-RA proof of F0 --,. That it is complete follows from the fact that consistent maximal extensions are Hintikka sets. In particular, every generator F,A,B--* C has the same truth conditions as the set of formulas F U {',AV'~BVC}. So a maximal extension is a Hintikka set if it contains either -,A or \"~B or C for every generator. The exhaustiveness of our search assures this: every pair of constraints is checked at least once to see if it matches a","3 In fact, every connected pair has two connected forms: Sl(x,y), S2(y,z) and T~(z,y), Tl(y,z). Unsurprisingly, in this case the output of the generator table for T2 and T: will be the inverse of what it is for S~ and $2. In either case, the output will be placed in normal order before being entered into the description, so we have the required commutativity, generator. If it does not then the extension must contain either \",A or -~B. If it does, then the extension contains A and B, and so it must also contain C, or be found inconsistent by the Meet Rule/RA.","However, completeness is purchased at the cost of the complexities of exhaustive search. Note that the Splitting Rule is the only source of non-determinism in the program. All of the routines whose definitions were left out are deterministic. The ordered set manipulations are linear in the size of the combined input lists; the sort called by the Meet Rule is just a variant of merge-sort, and so of"]},{"title":"N logN","paragraphs":["complexity; the many inversions which may have to be done are linear in the length of the constraint list, which is bounded from above by 4, so they can be treated as constant time operations. It is only the Splitting Rule that causes us trouble. The second algorithm attempts to address this problem."]},{"title":"CLOSE : POLYNOMIAL SEARCH FOR A Lv-RA PROOF","paragraphs":["The basic design problem to be solved is that the generator table accepts only atomic formulas as inputs, while the description whose consistency is at issue may contain any number of compound formulas."]},{"title":"Extend","paragraphs":["solved this problem by 'bringing the description to the generators,'"]},{"title":"Close","paragraphs":["solves this problem by 'bringing the generators to the description.' Figure 6 represents a proof that {dp(1,2),bf(1,B),dp(2,3)} is inconsistent. Here the leaves are almost entirely drawn from the generator axioms. Only the rightmost leaf invokes a structural axiom. The initial stages of the proof involve combining generators by means of RV and LV until the two antecedent atoms match a pair of compound atoms found in the input description (in this case"]},{"title":"dp(1,2)","paragraphs":["and dp(2,3)). Then this 'compound generator' is fed into the RA rule together with the corresponding structural axiom, generating our inconsistency."]},{"title":"Close,","paragraphs":["like"]},{"title":"extend,","paragraphs":["implements a backwards chaining search for a proof of the relevant sort. The code for the two algorithms has been made almost identical, for the purposes of this paper. The sole essential difference is that now consequences/3 has only one clause, which invokes the New Generator Rule. The input to new_generator_rule/3 is the same as the input to generator_rule/3: the current description, a constraint looking to be the left antecedent of a generator, and the output consequences. Like the old rule, the new rule searches the current description for a connected formula (now not 168 RV bf(l,3),d(l,2),d(2,3) --, d(l,3) bf(1,3),p(l,2),d(2,3) --* p(l,3) RV LV bf(1,3),d(1,2),d(2,3) --. dp(1,3)","bf(1,3),p(1,2),d(2,3) --. dp(1,3) bf(l,a),dp(l,2),d(2,3) --. dp(l,3)"]},{"title":"V","paragraphs":["bf(1,3),p(1,2),p(2,3) ---, p(1,3)","Lv bf(1,3),d(1,2),p(2,3) -. @(1,3) bf(1,3),p(1,2),p(2,3) -, @(1,3) bf(1,3),dp(1,2),p(2,3) -, dp(1,3)"]},{"title":"V A A","paragraphs":["Lv bf(1,3),dp(1,2),d(Z,3) -, @(1,3) bf(1,3),dp(1,Z),p(2,3) --, @(1,3) RA bf(1,3),dp(1,Z),dp(2,3) ~ dp(1,3)","dp(1,2),dp(2,3),bf(1,3) -. bf(1,3) dp(l,2),bf(l,3),dp(2,3) ---. (1,3) Rv Figure 6. A LV-RA Proof that {dp(1,2), bf(1,3), dp(2,3)} is Inconsistent. necessarily atomic). From the resulting connected pair it constructs a compound generator by taking the cross product of the atomic relations in the compound formulas (in a double loop implemented in distribute/4 and distrib_l/4), feeding the atomic pairs so constructed to the generator table (in distrib 1/4), and joining each successive generator output. The result is a compound generator whose consequent represents the join of all the atomic generators that went into its construction."]},{"title":"newgeneratorrule(","paragraphs":["U, _C, fl )-","new generator_rule( [C21Rest], C1, [C31Cons] ) :- connected_order( C1, C2, $1 :(X,Y), S2:(Y,Z) ), distribute( $1 :(X,Y), S2:(Y,Z), []:(X,Z), S3:(X,Z) ), normal_order(S3:(X,Z), C3 ), new_generator_rule( Rest, C1, Cons ).","new_generator_rule( [C21Rest], C1, Cons ) :- \\+ connected order( C1, C2 .... ), new_generator_rule( Rest, C1, Cons ).","distribute( ~:_, _C2, Cons, Cons ).","distribute( [RIlS1]:XY, S2:YZ, S3a:XZ, S3:XZ ) :-","distrib_J (S2:YZ, [RlJ:XY, S3a:XZ, S3b:XZ ),","distribute( $1 :XY, S2:YZ, S3b:XZ, S3:XZ ).","distdb_l( [].'.._, _C1, Cons, Cons ).","dislrib_l( [R21S2]:YZ, $1 :XY, S3a:XZ, S3:XZ ) :- gen( $1 :XY. [R2]:YZ, S3b:XZ ), ord_union( S3a, S3b, $3c ), distrib 1 ( S2:YZ, $1 :XY, S3c:XZ, S3:XZ ). On completion of the double loop, control works its way back to consequences/3 and thence to the Meet Rule, as usual.","Unlike extend, close is deterministic. Each agenda item is compared to each item in the current description, and that is that. Furthermore, the complexity of the New Generator Rule is not much greater than before: the double loop we have added can only be executed a maximum of 4 x 4 -- 16 times, so we have increased the complexity of the algorithm, considered apart from the Splitting Rule, by at most a constant factor. The question is: at what cost?","Before we turn to the analysis of close, however, note that its output is different from that of extend. Extend returns a maximal extension, selected non-deterministically. Close returns the input description, but with values that could not be part of any solution removed. Essentially, close returns the pointwise join of all of F0's consistent maximal extensions.","This action, of joining all the atomic consequences of a pair of constraints, does not preserve all of the information present in the atomic consequences. Consider the following description. F0 : {d(1,2), dp(1,3), dp(2,3)} F0 is its own closure, and is consistent. However, if we examine its maximal extensions, we note that one of them r3 : {d(1,2), p(1,3), d(2,3)} is inconsistent. There is nothing in F0 to tell us that one combination of the values it presents is impossible. Note that this may not be essential to proving inconsistency: for F0 to be inconsistent, it would have to be the case that all values in some constraint were ruled out in all maximal extensions. 169"]},{"title":"ANALYSIS OF CLOSE","paragraphs":["We first argue that"]},{"title":"close","paragraphs":["is indeed finding a LV-RA proof of F0 --,. Note that in our toy example of Figure 6 only a single 'compound generator' was required to derive the empty solution. In general it may take several compound generators to build a proof of F0--*. Each one functions to remove some of the possibilities from a constraint, until eventually no possibilities are left. Thus we have a LV-RA proof of F0-, if and only if we have a proof of FQ --, (x,y), for some x and y. Let us call such a (not necessarily unique) pair a"]},{"title":"critical pair","paragraphs":["in the proof of F0---,, and its associated constraint in F0 a"]},{"title":"critical constraint.","paragraphs":["It is not at all obvious how to choose a critical constraint beforehand, so"]},{"title":"close","paragraphs":["must search for it. Every time it calls the New Generator Rule and then calls the Meet Rule to merge in its consequence, it constructs a fragment of a LV-RA proof. We could then take the constraint which it finally succeeds in emptying out as the critical constraint, collect the proof fragments having that constraint as their succedent, and plug them together in the order they were generated to supply us with a LV-RA proof of F0 --*."]},{"title":"So close","paragraphs":["will find a LV-RA proof of F0-,, if one exists. It is not clear, however, that such a proof always exists when F0 is unsatisfiable."]},{"title":"Close","paragraphs":["is essentially a variant of the path-consistency algorithms frequently discussed in the Constraint Satisfaction literature (IVlackworth, 1977; Allen, 1983). It is known that path-consistency is not in general a strong enough condition to ensure completeness. There are, however, special cases where path-consistency techniques are complete (Montanari,"]},{"title":"1974).","paragraphs":["So far,"]},{"title":"close","paragraphs":["appears to be complete, (two years of work have failed to turn up a counterexample) but it is unlikely to yield an easy completeness proof. The algorithm presented here is strongly reminiscent of the algorithm in Allen (1983), which is demonstrably incomplete for the temporal reasoning problems to which he applied it. Therefore, if"]},{"title":"close","paragraphs":["is complete for D-theory, it can only be due to a property of the generator axioms, that is, to properties of trees, as contrasted with properties of temporal intervals. Standard approaches of any generality will almost certainly generalize to the temporal reasoning case."]},{"title":"REFERENCES","paragraphs":["Allen, 2ames F. 1983. Maintaining Knowledge about Temporal Intervals."]},{"title":"Communications of the ACM","paragraphs":["26(11): 832-843. Cornell, Thomas L. 1992."]},{"title":"Description Theory, Licensing Theory and Principle-Based Grammars and Parsers.","paragraphs":["UCLA Ph.D. thesis.","Gorrell, P. 1991. Subcategorization and Sentence Processing. In Berwick, R., S. Abney & C. Tenney, eds."]},{"title":"Principle-Based Parsing: Computation and Psycholinguistics.","paragraphs":["Kluwer, Dordrecht. Mackworth, Alan K."]},{"title":"1977.","paragraphs":["Consistency in Networks of Relations."]},{"title":"Artificial Intelligence","paragraphs":["8: 99-118.","Marcus, Mitchell P., & Donald Hindle. (1990). Description Theory and Intonation Boundaries. In G. T. M. Ahman (Ed.),"]},{"title":"Cognitioe Models of Speech Processing","paragraphs":["(pp. 483-512). Cambridge, MA: MIT Press.","Marcus, Mitchell P., Donald Hindle & Margaret M. Fleck. 1983. D-Theory: Talking about Talking about Trees."]},{"title":"Proceedings of the 21st Mtg. of the A CL.","paragraphs":["Montanari, Ugo. 1974. Networks of Constraints: Fundamental Properties and Applications to Picture Processing."]},{"title":"Information Sciences 7:","paragraphs":["95-132. O'Keefe, Richard A. 1990. The"]},{"title":"Craft of Prolog.","paragraphs":["Cambridge, MA: MIT Press.","Rogers, 3ames & K. Vijay-Shanker. 1992. Reasoning with Descriptions of Trees."]},{"title":"Proceedings of the 30th Mtg. of the ACL.","paragraphs":["Weinberg, A. 1988."]},{"title":"Locality Principles in Syntax and in Parsing.","paragraphs":["MIT Ph.D. dissertation. 170"]}]}
