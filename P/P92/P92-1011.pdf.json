{"sections":[{"title":"COMPARING TWO GRAMMAR-BASED GENERATION A CASE STUDY Miroslav Martinovic and Tomek Strzalkowski","paragraphs":["Courant Institute of Mathematical Sciences New York University 715 Broadway, rm. 704 New York, N.Y., 10003"]},{"title":"ALGORITHMS:","paragraphs":["ABSTRACT In this paper we compare two grammar-based generation algorithms: the Semantic-Head-Driven Generation Algorithm (SHDGA), and the Essential Arguments Algorithm (EAA). Both algorithms have successfully addressed several outstanding problems in grammar-based generation, including dealing with non-monotonic compositionality of representation, left-recursion, deadlock-prone rules, and nondeterminism. We concentrate here on the comparison of selected properties: generality, efficiency, and determinism. We show that EAA's traversals of the analysis tree for a given language construct, include also the one taken on by SHDGA. We also demonstrate specific and common situations in which SHDGA will invariably run into serious inefficiency and nondeterminism, and which EAA will handle in an efficient and deterministic manner. We also point out that only EAA allows to treat the underlying grammar in a truly multi-directional manner. 1. INTRODUCTION Recently, two important new algorithms have been published ([SNMP89], [SNMP90], [S90a], [S90b] and [$91]) that address the problem of automated generation of natural language expressions from a structured representation of meaning. Both algorithms follow the same general principle: given a grammar, and a structured representation of meaning, produce one or more corresponding surface strings, and do so with a minimal possible effort. In this paper we limit our analysis of the two algorithms to unification-based formalisms. The first algorithm, which we call here the Semantic-Head-Driven Generation Algorithm (SHDGA), uses information about semantic heads ~ in grammar rules to obtain the best possible traversal of the generation tree, using a mixed top-down/bottom-up strategy.","The semantic head of a rule is the literal on the right-hand side that shares the semantics with the literal on the left. The second algorithm, which we call the Essential Arguments Algorithm (EAA), rearranges grammar productions at compile time in such a way that a simple top-down left-to-right evaluation will follow an optimal path.","Both algorithms have resolved several outstanding problems in dealing with natural language grammars, including handling of left recursive rules, non-monotonic compositionality of representation, and deadlock-prone rules 2. In this paper we attempt to compare these two algorithms along their generality and efficiency lines. Throughout this paper we follow the notation used in [SNMP90].","2. MAIN CHARACTERISTICS OF SHDGA'S AND EAA'S TRAVERSALS SHDGA traverses the derivation tree in the semantic-head-first fashion. Starting from the goal predicate node (called the"]},{"title":"root),","paragraphs":["containing a structured representation (semantics) from which to generate, it selects a production whose leg-hand side semantics unifies with the semantics of the root. If the selected production passes the semantics unchanged from the left to some nonterminal on the right (the so-called"]},{"title":"chain rule),","paragraphs":["this later nonterminal becomes the new root and the algorithm is applied recursively. On the other hand, if no right-hand side literal has the same semantics as the root (the so called"]},{"title":"non-chain rule),","paragraphs":["the production is expanded, and the algorithm is reeursively applied to every literal on its right-hand side. When the evaluation of a non-chain rule is completed, SHDGA connects its left-hand side literal (called the"]},{"title":"pivot)","paragraphs":["to the initial root using (in a backward manner) a series of appropriate chain rules. At this time, all remaining literals in the chain rules are expanded in a fixed order (left-to-right). 81 2 Deadlock-prone rules are rules in which the order of the expansion of right-hand side literals cannot be determined locally (i.e. using only information available in this rule).","Since SHDGA traverses the derivation tree ha the fashion described above, this traversal is neither top-down ('I'D), nor bottom-up (BU), nor left-to-right (LR) globally, with respect to the entire tree. However, it is LR locally, when the siblings of the semantic head literal are selected for expansion on the right-hand side of a chain rule, or when a non-chain rule is evaluated. In fact the overall traversal strategy combines both the TD mode (non-chain rule application) and the BU mode (backward application of chain rules).","EAA takes a unification grammar (usually Prologcoded) and normalizes it by rewriting certain left recursive rules and altering the order of right-hand side nonterminals in other rules. It reorders literals ha the original grammar (both locally within each rule, and globally between different rules) ha such a way that the optimal traversal order is achieved for a given evaluation strategy (eg. top-down left-to-righ0. This restructuring is done at compile time, so in effect a new executable grammar is produced. The resulting parser or generator is TD but not LR with respect to the original grammar, however, the new grammar is evaluated TD and LR (i.e., using a standard Prolog interpreter). As a part of the node reordering process EAA calculates the minimal sets of essential arguments (msea's) for all literals ha the grammar, which in turn will allow to project an optimal evaluation order. The optimal evaluation order is achieved by expanding only those literals which are ready at any given moment, i.e., those that have at least one of their mseas instantiated. The following example illustrates the traversal strategies of both algorithms. The grammar is taken from [SNMP90], and normalized to remove deadlock-prone rules in order to simplify the exposition? (0) sentence/deel(S)--> s(f'mite)/S. (1) sentence/imp(S) -- > vp(nonfmite,[np(_)/you])","IS.",",,..... (2)","s(Form)/S - > Subj, vp(Form,[Subj/S. ...°°°. (3)","vp(Form,Subcat)/S -- > v(Form,Z)/S, vpl(Form,Z)/Subcat. (4) vpl(Form,[Compl[ Z])/Ar --> vpl(Form, Z)/Ar,","Compl. (5) vpl(Form,Ar)/Ar. (6)","vp(Form,[Subj])/S -- > v(Form,[Subj])/VP, anx(Form, [Subj],VP)/S."]},{"title":"(7) anx(Form,[Subjl,S)/S.","paragraphs":["(8) aux(Form,[Subjl,A)/Z--> adv(A)/B,","aux(Form[Subj],B)/Z.","....... (9) v(finite,[np(_)/O,np(3-sing)lS])llove(S,O) -- >","[loves].","(10) v(f'mite, [np(_)/O,p/up,np(3 -sing)/S])/","call_up(S,O) -- > [calls].","(11) v(fmite,[np(3-sing)/S])/leave(S) -- > [leaves].","......","° (12) np(3-sing)/john -- > [john]. (13) np(3-pl)/friends -- > [friends]. (14) adv(VP)/often(VP)--> [often]. The analysis tree for both algorithms is presented on the next page. (Figure 1.). The input semantics is given as decl(call_up~ohnfriends)). The output string becomes john calls up friends. The difference lists for each step are also provided. They are separated from the rest of the predicate by the symbol I- The different orders in which the two algorithms expand the branches of the derivation tree and generate the terminal nodes are marked, ha italics for SHDGA, and in roman case for EAA. The rules that were applied at each level are also given. If EAA is rerun for alternative solutions, it will produce the same output string, but the order in which nodes vpl (finite,[p/up,np(3-sing)/john])/[Subj]/Sl_S2, and np(..)/~ends/S2__l] (level 4), and also, vp1(finite,[np(3-sing)/john])/[Subj]/S1_S12, and p/up/S12_S2, at the level below, are visited, will be reversed. This happens because both literals in both pairs are ready for the expansion at the moment when the selection is to be made. Note that the traversal made by SHDGA and the first traversal taken by EAA actually generate the terminal nodes ha the same order. This property is formally defined below.","Definition. Two traversals T' and T\" of a tree T are","said to be the same-to-a-subtree (stas), if the follow-","hag claim holds: Let N be any node of the tree T, and","S~ ..... S all subtrees rooted at N. If the order in which","the subtrees will be taken on for the traversal by T' is","S? ..... S. n and by T\" S. t ..... S.\", then SJ =SJ ..... S.\"=S.\". s","s",".1","J","l",".I","t","j","(S~ is one of the subtrees rooted at N, for any k, and 1) Stas however does not imply that the order in which the nodes are visited will necessarily be the same. 3 EAA eliminates such rules using global node reordering ([$91]). 82 sentence/decl(call._up0ohn, friends)) I St ring_[l s(ftnite)/call up(john, friends) IString._[] SubJ l String_SO npO-slng)/joh n I String_SO np(3-sing)/john I UohnlS0LS0"]},{"title":"10/ Rule (12)","paragraphs":["john /V IV q)(rmJte,ISubjl)/caUup(john,trien~) I S0_[] v(finite,Z)/call_up0ohn, friends) I SOSI vpl(nnlte,Z)/lSubjl I Sl [1 v(finite,[np("]},{"title":")/friends,p/up, np(3-~ng)/john])/","paragraphs":["vpl(finite, [npO/friends,p/up, np(3-sing)/john])/ i~t]l_u p(j oh n, friends) I lcalls[ SII._Sl [SubjllSl_.[]"]},{"title":"S Rule(lO)","paragraphs":["calls vpl(finite, [p/up,ni)(3-singJIjohn])/[Subj] ISIS2 I I $ 6 RUle (4) vpl(flnite, [np(3-sing)/john)/[Subj] [ SI._S12 p/uplSl2_S2"]},{"title":"l","paragraphs":["o/upll~l~l_S2 4 7 RUle(S) 6 Is"]},{"title":"v'pl(fln~,[np(3-slng)/john])/[np(3-si~ljohn] l Sl_ Sl","paragraphs":["H up U Rule ~0)"]},{"title":"Rule (1)","paragraphs":["Rul¢~ Sule~ up(_)/rr~lS2_[l","np(3-pl)/frlendsl[~l Ill","8"]},{"title":"1 9 Rule (13) 11I friends","paragraphs":["III FIGURE 1: EAA's and SHDGA's Traversals of An Analysis Tree.","3. GENERALITY-WISE SUPERIORITY OF EAA OVER SHDGA","The traversals by SHDGA and EAA as marked on the graph are stas. This means that the order in which the terminals were produced (the leaves were visited) is the same (in this case: calls up friends john). As noted previously, EAA can make other traversals to produce the same output string, and the order in which the terminals are generated will be different in each case. (This should not be confused with the order of the terminals in the output string, which is always the same). The orders in which terminals are generated during alternative EAA traversals are: up calls friends john, friends calls up john, friends up calls john. In general, EAA can be forced to make a traversal corresponding to any permutation of ready literals in the right-hand side of a rule. We should notice that in the above example SHDGA happened to make all the right moves, i.e., it always expanded a literal whose msea happened to be instantiated. As we will see in the following sections, this will not always be the case for SHDGA and will become a source of serious efficiency problems. On the other hand, whenever SHDGA indeed follows an optimal traversal, EAA will have a traversal that is same-to-a-subtree with it.","The previous discussion can be summarized by the next theorem. 83 Theorem: If the SHDGA, at each particular step during its implicit traversal of the analysis tree, visits only the vertices representing literals that have at least one of their sets of essential arguments instantiated at the moment of the visit, then the traversal taken by the SHDGA is the same-to-a-subtree (stas) as one of the traversals taken by EAA. The claim of the theorem is an immediate consequence of two facts. The first is that the EAA always selects for the expansion one of the literals with a msea currently instantiated. The other is the definition of traversals being same-to-a-subtree (always choosing the same subtree for the next traversal).","The following simple extract from a grammar, defining a wh-question, illustrates the forementioned (see Figure 2. below): ........ .°","(1) whques/WhSem--> whsubj(Num)/WhSubj,","whpred(Num,Tense, [WhSubj,WhObj])","/WhSem, whobj/WhObj.","o.o ...... . ....... ,.° (2) whsubj(_.)/who -- > [who]. (3) whsubj(__)/what --> [what].","°° ...... ,° (4) whpred(sing,perf, [Subj, Obj])/wrote(Subj, Obj)"]},{"title":"-> [wrote].","paragraphs":["...°.,,,°,","(5) whobj/this--> [this]. °°oo,ooo°°","The input semantics for this example is wrote(who,this), and the output string who wrote this. The numbering for the edges taken by the SHDGA is given in italics, and for the EAA in roman case. Both algorithm~ expand the middle subtree first, then the left, and finally the right one. Each of the three subtrees has only one path, therefore the choices of their subtrees are unique, and therefore both algorithms agree on that, too. However, the way they actually traverse these subtrees is different. For example, the middle subtree is traversed bottom-up by SHDGA and top-down by EAA. whpred is expanded first by SI-IDGA (because it shares the semantics with the root, and there is an applicable non-chain rule), and also by EAA (because it is the only literal on the right-hand side of the rule (1) that has one of its msea's instantiated (its semantics)). After the middle subtree is completely expanded, both sibling literals for the whpred have their semantics instantiated and thus they are both ready for expansion. We must note that SHDGA will always select the leftmost literal (in this case, whsubj), whether it is ready or not. EAA will select the same in the first pass, but it will expand whobj first, and then whsubj, if we force a second pass. In the first pass, the terminals are generated in the order wrote who this, while in the second pass the order is wrote this who. The first traversal for EAA, and the only one for SHDGA are same-to-a-subtree.","4. EFFICIENCY-WISE SUPERIORITY OF EAA OVER SHDGA The following example is a simplified fragment of a parser-oriented grammar for yes or no questions. Using this fragment we will illustrate some deficiencies of SHDGA.","o.°o.ooo.. (1) sentence/ques(askif(S)) -- > yesnoq/askif(S)."]},{"title":"(2i\" ye's'noq/asld f(S)-->","paragraphs":["auxverb(Num,Pers,Form)/Aux, subj (Num,Pers)/Subj, mainverb(Form, [Sub j, Obj])/Verb, obj(_,J/Obj, adj([Verb])/S. wb,p~wr~e(wko.a,~) [ Q,m_U whs~bj(Num)/WhSJj l (~,es RI","whpred(Num, Form, [WhSubj,WhObjD/ wrole(who,this) I RIR2 wl~bj/WhObj I~_11 1 2","wrote 1 I 3 3 ~4 4 w~ thh H ll~ill !I! ~TJ, t* O) su~ 4er3 1II ~\" 11 FIGURE 2: EAA's and SHDGA's"]},{"title":"STAS Traversals of Who Question's Analysis Tree. 84","paragraphs":["(3) auxverb(sing, one,pres__perf)/laave(pres__perf, sing) --> [have].","(4) aux_verb(sing,one,pres_cont)/be(pres_cont, sing-l)--> [am]. (5) auxverb(sing,one,pres)/do(pres,sing- 1) -- > [do]. (6) aux_verb(sing,two,pres)/do(pres,sing-2)--> [do]. (7) aux_verb(sing,three,pres)/do(pres,sing-3) -- >","[does]. (8) aux_verb(pl,one,pres)/do(pres,pl-1) -- > [do]. (9) subj(Num,Pers)/Subj -- > np(Num, Pers,su)/Subj. (10) obj(Num,Pers)/Obj -- > np(Num,Pers,ob)/Obj. (11) np(Num,Pers,Case)/NP","--> noun(Num,Pers, Case)/NP. (12) np(Num,Pers,Case)/NP","--> pnoun(Num,Pers, Case)/NP. (13) pnoun(sing,two,su)/you -- > [you]. (14) pnoun(sing,three,ob)/him -- > [him].","(15) main_verb(pres,[Subj,Obj])/see(Subj,Obj)","--> [see].","(15a) main_verb(pres__perf, [Subj, Obj ])/seen(Subj, Obj )","--> [seen].","(15b) mainverb(perf, [Subj,Obj])/saw(Subj, Obj)","-->"]},{"title":"[saw].","paragraphs":["(16) adj([Verb])/often(Verb)--> [often]. The analysis tree (given on Figure 3.) for the input semantics"]},{"title":"ques ( askif (often (see (you,him) ) ) )","paragraphs":["(the output string being"]},{"title":"do you see him often)","paragraphs":["is presented below.","Both algorithms start with the rule (1). SHDGA selects (1) because it has the left-hand side nonterminal with the same semantics as the root, and it is a non-chain rule. EAA selects (1) because its left-hand side unifies with the initial query"]},{"title":"(-?- sentence (OutString__G) / ques(askif(often(see(you,him)))) ).","paragraphs":["Next, rule (2) is selected by both algorithms. Again, by SHDGA, because it has the left-hand side nonterminal with the same semantics as the current root (yesnoq/askif...), and it is a non-chain rule; and by EAA, because the yesnoq/askif.., is the only nonterminal on the right-hand side of the previously chosen rule and it has an instantiated msea (its semantics). The crucial difference takes place when the right-hand side of rule (2) is processed. EAA deterministically selects"]},{"title":"adj","paragraphs":["for expansion, because it is the only rhs literal with an instantiated msea's. As a result of expanding"]},{"title":"adj,","paragraphs":["the main verb semantics becomes instantiated, and therefore"]},{"title":"main__verb is the","paragraphs":["next literal selected for expansion. After processing of"]},{"title":"main_verb","paragraphs":["is completed,"]},{"title":"Subject, Object, and Tense","paragraphs":["variables are instantiated, so that both"]},{"title":"subj and obj","paragraphs":["become ready. Also, the tense argument for"]},{"title":"aux_verb","paragraphs":["is instantiated"]},{"title":"(Form in rule","paragraphs":["(2)). After"]},{"title":"subj,","paragraphs":["se ntee~e/ques(askifloft en(see(yoo,him)))) ] String_[] '"]},{"title":"I 1","paragraphs":["yesnoqlaskiffonenlsee(you,him))) [ String_[] Ru~ (z) Rule aux_verb(sing,t wo, pres)/ do(pres,sing-2) [ Idol ROI_R0 Rule(o) 11 3","do V 1 sobj(sing,two)/ main_verb(pres, [you, him])/ obj(sing,three) youI[youlRl] RI see(you,him) ] [see [ R2]_R2 him [ [him ] R3]_R3 Role (9) Rule (15) Rule (10) 5 6 4 7 8 10 np(sing,two,su)/ see np(sing,three,ob)/ you I [you I R I]_RI 1I II1 him I [him [ R3]_R3"]},{"title":"Rule.z)[ Rule(l,) I","paragraphs":["6 5 9 9 pnoun(sing,two,su)/ pnoun(slng,three,ob)/ you I [you[ RI]RI him l [him I R3LR3 Rule (13) ] Rule (14) I 7 4 10 8 you him llI // IV /V","adj([see(you,him) ])/ often(see( you, him)) I [one~ I [ILl Rule"]},{"title":"(16) I","paragraphs":["3 11 often I V FIGURE 3: EAA's and SHDGA's Traversals of"]},{"title":"If Question's Analysis Tree. 85 and obj","paragraphs":["are expanded (in any order),"]},{"title":"Num, and Pers","paragraphs":["for"]},{"title":"aux_verb","paragraphs":["are bound, and finally"]},{"title":"aux_verb","paragraphs":["is ready, too.","In contrast, the SHDGA will proceed by selecting the leftmost literal"]},{"title":"(auxverb(Num,Pers,Form)/Aux)","paragraphs":["of the rule (2). At this moment, none of its arguments is instantiated and any attempt to unify with an auxiliary verb in a lexicon will succeed. Suppose then that"]},{"title":"have","paragraphs":["is returned and unified with aux_verb with"]},{"title":"pres._perf as Tense and sing_l as Number.","paragraphs":["This restricts further choices of"]},{"title":"subj and main_verb.","paragraphs":["However,"]},{"title":"obj","paragraphs":["will still be completely randomly chosen, and then adj will reject all previous choices. The decision for rejecting them will come when the literal adj is expanded, because its semantics is"]},{"title":"often(see(you,him)) as","paragraphs":["inherited from"]},{"title":"yesnoq,","paragraphs":["but it does not match the previous choices for"]},{"title":"aux_verb, subj, main_verb, and obj. Thus","paragraphs":["we are forced to backtrack repeatedly, and it may be a while before the correct choices are made. In fact the same problem will occur whenever SHDGA selects a rule for expansion such that its leftmost right-hand side literal (first to be processed) is not"]},{"title":"ready.","paragraphs":["Since SHDGA does not check for"]},{"title":"readiness","paragraphs":["before expanding a predicate, other examples similar to the one discussed above can be found easily. We may also point out that the fragment used in the previous example is extracted from an actual computer grammar for English (Sager's String Grammar), and therefore, it is not an artificial problem. The only way to avoid such problems with SHDGA would be to rewrite the underlying grammar, so that the choice of the most instantiated literal on the righthand side of a rule is forced. This could be done by changing rule (2) in the example above into several rules which use meta nonterminals"]},{"title":"Aux, Subj, Main_Verb, and Obj","paragraphs":["in place of literals"]},{"title":"attx verb, subj, mainverb, and obj","paragraphs":["respectively, as shown below: .....°.... yesnoq/askif(S)--> askif/S. askif/S -- >","Aux, Subj, Main Verb, Obj,","adj ([Verb],[Aux,S-ubj,Main_Verb,Obj])IS. .......... Since"]},{"title":"Aux, Subj, Main_Verb, and Obj","paragraphs":["are uninstantiated variables, we are forced to go directly to adj first. After adj is expanded the nonterminals to the left of it will become properly instantiated for expansion, so in effect their expansion has been delayed. However, this solution seems to put additional burden on the grammar writer, who need not be aware of the evaluation strategy to be used for its grammar. Both algorithms handle left recursion satisfactorily. SHDGA processes recursive chain rules rules in a constrained bottom-up fashion, and this also includes deadlock prone rules. EAA gets rid of left recursive rules during the grammar normalization process that takes place at compile-time, thus avoiding the run-time overhead. 5. MULTI-DIRECTIONALITY Another property of EAA regarded as superior over the SHDGA is its mult-direcfionality. EAA can be used for parsing as well as for generation. The algorithm will simply recognize that the top-level msea is now the string, and will adjust to the new situation. Moreover, EAA can be run in any direction"]},{"title":"paved","paragraphs":["by the predicates' mseas as they become instantiated at the time a rule is taken up for expansion. In contrast, SHDGA can only be guaranteed to work in one direction, given any particular grammar, although the same architecture can apparently be used for both generation, [SNMP90], and parsing, [K90], [N89].","The point is that some grammars (as shown in the example above) need to be rewritten for parsing or generation, or else they must be constructed in such a way so as to avoid indeterminacy. While it is possible to rewrite grammars in a form appropriate for head-first computation, there are real grammars which will not evaluate efficiently with SHDGA, even though EAA can handle such grammars with no problems. 6. CONCLUSION In this paper we discussed several aspects of two natural language generation algorithms: SHDGA and EAA. Both algorithms operate under the same general set of conditions, that is, given a grammar, and a structured representation of meaning, they attempt to produce one or more corresponding surface strings, and do so with a minimal possible effort. We analyzed the performance of each algorithm in a few specific situations, and concluded that EAA is both more general and more efficient algorithm than SHDGA. Where EAA enforces the optimal traversal of the derivation tree by precomputing all possible orderings for nonterminal expansion, SHDGA can be guaranteed to display a compa-86 rable performance only if its grammar is appropriately designed, and the"]},{"title":"semantic heads","paragraphs":["are carefully assigned (manually). With other grammars SHDGA will follow non-optimal generation paths which may lead to extreme inefficiency.","In addition, EAA is a truly multi-directional algorithm, while SHDGA is not, which is a simple consequence of the restricted form of grammar that SHDGA can safely accept. This comparison can be broadened in several directions. For example, an interesting problem that remains to be worked out is a formal characterization of the grammars for which each of the two generation algorithms is guaranteed to produce a finite and/or optimal search tree. Moreover, while we showed that SHDGA will work properly only on a subset of EAA's grammars, there may be legitimate g~ that neither algorithm can handle. 7. ACKNOWLEDGEMENTS","This paper is based upon work supported by the Defense Advanced Research Project Agency under Contract N00014-90-J-1851 from the Office of Naval Research, the National Science Foundation under Grant IRI-89-02304, and the Canadian Institute for Robotics and Intelligent Systems (IRIS). REFERENCES","[C78] COLMERAUER, A. 1978. \"Metamorphosis Grammars.\" In"]},{"title":"Natural Language Communi- cation with Computers,","paragraphs":["Edited by L. Bole. Lecture Notes in Computer Science, 63. Springer-Verlag, New York, NY, pp. 133-189.","[D90a] DYMETMAN, M. 1990. \"A Generalized Greibach Normal Form for DCG's.\" CCRIT, Laval, Quebec: Ministere des Communications Canada.","[D90b] DYMETMAN, M. 1990. \"Left-Recursion Elimination, Guiding, and Bidirectionality in Lexical Grammars.\" To Appear. [DA84] DAHL, V., and ABRAMSON, H. 1984. \"On Gapping Grammars.\""]},{"title":"Proceedings of the Second International Conference on Logic Programming.Uppsala,","paragraphs":["Sweden, pp. 77-88. [DI88] DYMETMAN, M., and ISABELLE, P. 1988. \"Reversible Logic Grammars for Machine Translation.\""]},{"title":"Proceedings of the 2nd International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Languages.","paragraphs":["Carnegie-Mellon University, Pittsburgh, PA. [DIP90] DYMETMAN, M., ISABELLE, P., and PERRAULT, F. 1991. \"A Symmetrical Approach to Parsing and Generation.\""]},{"title":"Proceedings of the 13th International Conference on Computational Linguis- tics (COLING-90).","paragraphs":["Helsinki, Finland, Vol. 3., pp. 90-96. [GM89] GAZDAR, G., and MELLISH, C. 1989."]},{"title":"Natural £zmguage Processing in Prolog.","paragraphs":["Addison-Wesley, Reading, MA. [K90] KAY, M. 1990. \"Head-Driven Parsing.\" In M. Tomita (ed.),"]},{"title":"Current Issues in Parsing Technology,","paragraphs":["Kluwer Academic Publishers, Dordrecht, the Netherlands. [K84] KAY, M. 1984. \"Functional Unifica-tion Grammar: A Formalism for Machine Translation.\""]},{"title":"Proceedings of the lOth International Conference on Computational Linguistics (COLING-84).","paragraphs":["Stanford University, Stanford, CA., pp. 75-78. [N89] VAN NOORD, G. 1989. ~An Overview of Head-Driven Bottom-Up Generation.\" In Pro-"]},{"title":"ceedings of the Second European Workshop on Natu- ral Language Generation.","paragraphs":["Edinburgh, Scotland. [PS90] PENG, P., and STRZALKOWSKI, T. 1990. \"An Implementation of A Reversible Grammar.\""]},{"title":"Proceedings of the 8th Conference of the Catmdian So- ciety for the Computational Studies of Intelligence (CSCS1-90).","paragraphs":["University of Ottawa, Ottawa, Ontario, pp. 121-127. [S90a] STRZALKOWSKI, T. 1990. \"How to Invert A Natural Language Parser into An Efficient Generator: An Algorithm for Logic Grammars.\""]},{"title":"Proceed- ings of the 13th International Conference on Compu- tational Linguistics (COLING-90).","paragraphs":["Helsinki, Finland, Vol. 2., pp. 90-96. [S90b] STRZALKOWSKI, T. 1990. \"Reversible Logic Grammars for Natural Language Parsing and Generation.\""]},{"title":"Computational Intelligence Journal,","paragraphs":["Volume 6., pp. 145-171. 87 [$91] STRZALKOWSKI, T. 1991. \"A General Computational Method for Grammar Inversion.\""]},{"title":"Proceedings era Workshop Sponsored by the Special Interest Groups on Generation and Parsing of the ACL.","paragraphs":["Berkeley, CA., pp. 91-99. [SNMP89] SHIEBER, S.M., VAN NOORD, G., MOORE, R.C., and PEREIRA, F.C.N. 1989. \"A Semantic-Head-Driven Generation Algorithm for Unification-Based Formalisms.\""]},{"title":"Proceedings of the 27th Meeting of the ACL.","paragraphs":["Vancouver, B.C., pp. 7-17. [SNMP90] SHIEBER, S.M., VAN NOORD, G., MOORE, R.C., and PEREIRA, F.C.N. 1990. \"Semantic-Head-Driven Generation.\""]},{"title":"Computational Linguistics,","paragraphs":["Volume 16, Number 1.","[W88] WEDEKIND, J. 1988. \"Generation as Structure Driven Derivation.*"]},{"title":"Proceedings of the 12th International Conference on Computational Linguis- tics (COL1NG-88).","paragraphs":["Budapest, Hungary, pp. 732-737. 08"]}]}
