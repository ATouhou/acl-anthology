{"sections":[{"title":"","paragraphs":["Proceedings of the 13th Meeting on the Mathematics of Language (MoL 13), pages 83–92, Sofia, Bulgaria, August 9, 2013. c⃝2013 Association for Computational Linguistics"]},{"title":"Why Letter Substitution Puzzles are Not Hard to Solve: A Case Study in Entropy and Probabilistic Search-Complexity Eric Corlett University of Toronto 10 King’s College Rd., Room 3302 Toronto, ON, Canada M5S 3G4 ecorlett@cs.toronto.edu Gerald Penn University of Toronto 10 King’s College Rd., Room 3302 Toronto, ON, Canada M5S 3G4 gpenn@cs.toronto.edu Abstract","paragraphs":["In this paper we investigate the theoretical causes of the disparity between the theoretical and practical running times for the A∗","algorithm proposed in Corlett and Penn (2010) for deciphering letter-substitution ciphers. We argue that the difference seen is due to the relatively low entropies of the probability distributions of character transitions seen in natural language, and we develop a principled way of incorporat-ing entropy into our complexity analysis. Specifically, we find that the low entropy of natural languages can allow us, with high probability, to bound the depth of the heuristic values expanded in the search. This leads to a novel probabilistic bound on search depth in these tasks."]},{"title":"1 Introduction","paragraphs":["When working in NLP, we can find ourselves using algorithms whose worst-case running time bounds do not accurately describe their empirically determined running times. Specifically, we can often find that the algorithms that we are using can be made to run efficiently on real-world instances of their problems despite having theoretically high running times. Thus, we have an apparent disparity between the theoretical and practical running times of these algorithms, and so we must ask why these algorithms can provide results in a reasonable time frame. We must also ask to what extent we can expect our algorithms to remain practical as we change the downstream do-mains from which we draw problem instances.","At a high level, the reason such algorithms can work well in the real world is that the real world applications from which we draw our inputs do not tend to include the high complexity inputs. In other words, our problem space either does not cover all possible inputs to the algorithm, or it does, but with a probability distribution that gives a vanishingly small likelihood to the “hard” inputs. Thus, it would be beneficial to incorporate into our running time analysis the fact that our possible inputs are restricted, even if only restricted in relative frequency rather than in absolute terms.","This means that any running time that we observe must be considered to be dependent on the distribution of inputs that we expect to sample from. It probably does not come as a surprise that any empirical analysis of running time carries with it the assumption that the data on which the tests were run are typical of the data which we expect to see in practice. Yet the received wisdom on the asymptotic complexity of algorithms in computational linguistics (generally what one might see in an advanced undergraduate algorithms curriculum) has been content to consider input only in terms of its size or length, and not the distribution from which it was sampled. Indeed, many algorithms in NLP actually take entire distributions as input, such as language models. Without a more mature theoretical understanding of time complexity, it is not clear exactly what any empirical running time results would mean. A worst-case complexity result gives a guarantee that an algorithm will take no more than a certain number of steps to complete. An average-case result gives the expected number of steps to complete. But an empirical running time found by sampling from a distribution that is potentially different from what the algorithm was designed for is only a lesson in how truly different the distribution is.","It is also common for the theoretical study of asymptotic time complexity in NLP to focus on the worst-case complexity of a problem or algorithm rather than an expected complexity, in spite of the existence for now over 20 years of methods for average-case analysis of an algorithm. Even these, however, often assume a uniform distribu-83 tion over input, when in fact the true expectation must consider the probability distribution that we will draw the inputs from. Uniform distributions are only common because we may not know what the distribution is beforehand.","Ideally, we should want to characterize the running time of an algorithm using some known properties of its input distribution, even if the precise distribution is not known. Previous work that at-tempts this does exist. In particular, there is a variant of analysis referred to as smoothed analysis which gives a bound on the average-case running time of an algorithm under the assumption that all inputs are sampled with Gaussian measurement error. As we will argue in Section 2, however, this approach is of limited use to us.","We instead approach the disparity of theoretical and practical running time by making use of statistics such as entropy, which are taken from the input probability distributions, as eligible factors in our analysis of the running time complexity. This is a reasonable approach to the problem, in view of the numerous entropic studies of word and character distributions dating back to Shannon.","Specifically, we analyze the running time of the A∗","search algorithm described in Corlett and Penn (2010). This algorithm deciphers text that has been enciphered using a consistent letter substitution, and its running time is linear in the length of the text being deciphered, but theoretically exponential in the size of the input and output alphabets. This naı̈ve theoretical analysis assumes that characters are uniformly distributed, however. A far more informative bound is attainable by making reference to the entropy of the input. Because the algorithm takes a language model as one of its inputs (the algorithm is guaranteed to find the model-optimal letter substitution over a given text), there are actually two input distributions: the distribution assumed by the input language model, and the distribution from which the text to be deciphered was sampled. Another way to view this problem is as a search for a permutation of letters as the outcomes of one distribution such that the two distributions are maximally similar. So our informative bound is attained through reference to the cross-entropy of these two distributions.","We first formalize our innate assumption that these two distributions are similar, and build an upper bound for the algorithm’s complexity that incorporates the cross-entropy between the two distributions. The analysis concludes that, rather than being exponential in the length of the input or in the size of the alphabets, it is merely exponential in the cross-entropy of these two distributions, thus exposing the importance of their similarity. Essentially, our bound acts as a probability distribution over the necessary search depth."]},{"title":"2 Related Work","paragraphs":["The closest previous work to the analysis presented here is the use of smoothed analysis to explain the tractable real-world running time of a number of algorithms with an exponential worst-case complexity. These algorithms include the simplex algorithm, as described by Spielman and Teng (2004), the k-means clustering algorithm, as described by Arthur et al. (2009) and others. As in our current approach, smoothed analysis works by running a general average-case analysis of the algorithms without direct knowledge of the distribution from which the problem inputs have been drawn. The assumption made in smoothed analysis is that every input has been read with some Gaussian measurement error. That is, in a typical worst-case analysis, we may have an adversary choose any input for our algorithm, after which we must calculate how bad the resulting running time might be, but in a smoothed analysis, the adversary gives us input by placing it into the real world so that we may measure it, and this measurement adds a small error drawn from a Gaussian distribution to the problem instance. The point of smoothed analysis is to find the worst average-case running time, under these conditions, that the adversary can subject us to. Thus the analysis is an average case, subject to this error, of worst cases. In the papers cited above, this method of analysis was able to drop running times from exponential to polynomial.","It is unfortunate that this approach does not readily apply to many of the algorithms that we use in NLP. To see why this is, simply note that we can only add a small Gaussian error to our inputs if our inputs themselves are numerical. If the inputs to our algorithms are discrete, say, in the form of strings, then Gaussian errors are not meaningful. Rather, we must ask what sort of error we can expect to see in our inputs, and to what extent these errors contribute to the running time of our algorithms. In the case of decipherment, “error” is committed by substituting one character for an-84 other consistently.","The strongest known result on the search complexity of A∗","is given in Pearl (1984). This work found that, under certain assumptions, a bound on the absolute error between the heuristic used and the true best cost to reach the goal yields a polynomial worst-case depth for the search. This happens when the bound is constant across search instances of different sizes. On the other hand, if the relative error does not have this constant bound, the search complexity can still be exponential. This analysis assumes that the relative errors in the heuristic are independent between nodes of the search tree. It is also often very difficult even to calculate the value of a heuristic that possesses such a bound, as it might involve calculating the true best cost, which can be as difficult as completely solving a search problem instance (Korf et al., 2001). Thus, most practical heuristics still give rise to theoretically exponential search complexities in this view.","In Korf and Reid (1998) and Korf et al. (2001), on the other hand, several practical problems are treated, such as random k-SAT, Rubik’s cubes, or sliding tile puzzles, which are not wholly unlike deciphering letter substitution puzzles in that they calculate permutations, and therefore can assume, as we do, that overall time complexity directly corresponds to the number of nodes visited at different depths in the search tree that have a heuristic low enough to guarantee node expansion. But their analysis assumes that it is possible to both estimate and use a probability distribution of heuristic values on different nodes of the search graph, whereas in our task, this distribution is very difficult to sample because almost every node in the search graph has a worse heuristic score than the goal does, and would therefore never be expanded. Without an accurate idea of what the distribution of the heuristic is, we cannot accurately estimate the complexity of the algorithm. On the other hand, their analysis makes no use of any estimates of the cost of reaching the goal, because the practical problems that they consider do not allow for particularly accurate estimates. In our treatment, we find that the cost to reach the goal can be estimated with high probability, and that this estimate is much less than the cost of most nodes in the search graph. These different characteristics allow us to formulate a different sort of bound on the search complexity for the decipherment problem."]},{"title":"3 The Algorithm","paragraphs":["We now turn to the algorithm given in Corlett and Penn (2010) which we will investigate, and we explain the model we use to find our bound.","The purpose of the algorithm is to allow us to read a given ciphertext C which is assumed to be generated by putting an unknown plaintext P through an unknown monoalphabetic cipher.","We will denote the ciphertext alphabet as Σc and the plaintext alphabet as Σp. Given any string T , we will denote n(T ) as the length of T . Furthermore, we assume that the plaintext P is drawn from some string distribution q. We do not assume q to be a trigram distribution, but we do require it to be a distribution from which trigrams can be calculated (e.g, a 5-gram corpus will in general have probabilities that cannot be predicted using the associated trigrams, but the associated trigram corpus can be recovered from the 5-grams).","It is important to realize in the algorithm description and analysis that q may also not be known exactly, but we only assume that it exists, and that we can approximate it with a known trigram distribution p. In Corlett and Penn (2010), for example, p is the trigram distribution found using the Penn treebank. It is assumed that this is a good approximation for the distribution q, which in Corlett and Penn (2010) is the text in Wikipedia from which ciphers are drawn. As is common when dealing with probability distributions over natural languages, we assume that both p and q are stationary and ergodic, and we furthermore assume that p is smooth enough that any trigram that can be found in any string generated by q occurs in p (i.e., we assume that the cross entropy H(p, q) is finite).","The algorithm works in a model in which, for any run of the algorithm, the plaintext string P is drawn according to the distribution q. We do not directly observe P , but instead its encoding using the cipher key, which we will call πT . We observe the ciphertext C = π−1","T (P ). We note that πT is unknown, but that it does not change as new ciphertexts are drawn.","Now, the way that the algorithm in Corlett and Penn (2010) works is by searching over the possible keys to the cipher to find the one that maximizes the probability of the plaintext according to the distribution p. It does so as follows.","In addition to the possible keys to the cipher, 85 weakened cipher keys called partial solutions are added to the search space. A partial solution of size k (denoted as πk) is a section of a possible full cipher key which is only defined on k character types in the cipher. We consider the character types to be fixed according to some preset order, and so the k fixed letters in πk do not change between different partial solutions of size k. Given a partial solution πk, a string π","n(C)","k (C) is defined whose probability we use as an upper bound for the probability of the plaintext whenever the true solution to the cipher contains πk as a subset. The string π","n(C)","k (C) is the most likely string that we can find that is consistent with C on the letters fixed by πk. That is, we define the set Πk so that S ∈ Πk iff whenever si and ci are the characters at index i in S and C, then si = πk(ci) if ci is fixed in πk. Note that if ck is not fixed in πk, we let si take any value. We extend the partial character function to the full string function π n(C) k on Σ n(C) c so that π n(C) k (C) = argmax(S∈Πk)probp(S). In Corlett and Penn (2010), the value π","n(C)","k (C) is efficiently computed by running it through the Viterbi algorithm. That is, given C, p and πk, a run of the Viterbi algorithm is set up in which the letter transition probabilities are those that are given in p. In order to describe the emission probabilities, suppose that we partition the ciphertext alphabet Σc into two sets Σ1 and Σ2, where Σ1 is the set of ciphertext letters fixed by πk. For any plaintext letter y ∈ Σp, if there is a ciphertext letter x ∈ Σ1 such that y → x is a rule in πk, then the emission probability that y will be seen as x is set to 1, and the probability that y will be seen as any other letter is set to 0. On the other hand, if there is no rule y → x in πk for any ciphertext letter x, then the emission probability associated with y is uniform over the letters x ∈ Σ2 and 0 for the letters x ∈ Σ1.","The search algorithm described in Corlett and Penn (2010) uses the probability of the string π n(C) k (C), or more precisely, the log probability −logprobp(π","n(C)","k (C)), as an A∗","heuristic over the partial solutions πk. In this search, an edge is added from a size k partial solution πk to a size k + 1 partial solution πk+1 if πk agrees with πk+1 wherever it is defined. The score of a node πk is the log probability of its associated string: −logprobp(π","n(C)","k (C)). We can see that if πk has","an edge leading to πk+1, then Πk+1 ⊂ Πk, so that","−logprobp(π n(C) k+1 (C)) ≥ −logprobp(π","n(C)","k (C)). Thus, the heuristic is nondecreasing. Moreover, by applying the same statement inductively we can see that any full solution to the cipher that has πk as a subset must have a score at least as great as that of πk. This means that the score never over-estimates the cost of completing a solution, and therefore that the heuristic is admissible."]},{"title":"4 Analysis","paragraphs":["The bound that we will prove is that for any k > 0 and for any δ, ε > 0, there exists an n ∈ N such that if the length n(C) of the cipher C is at least n, then with probability at least 1 − δ, the search for the key to the cipher C requires no more than 2n·(H(p,q)+ε)","expansions of any partial solution of size k to complete. Applying the same bound over every size k of partial solution will then give us that for any δ, ε > 0, there exists a n0 > 0 such that if the length n(C) of the cipher C is at least n, then with probability at least 1 − δ, the search for the key to the cipher C requires no more than 2n(H(p,q)+ε)","expansions of any partial solution of size greater than 0 to complete (note that there is only one partial solution of size 0).","Let π∗","be the solution that is found by the search. This solution has the property that it is the full solution that induces the most probable plaintext from the cipher, and so it produces a plaintext that is at least as likely as that of the true solution P . Thus, we have that −logprobp(π∗n(C)","(C)) ≤ −logprobp(π","n(C)","T (C)) = −logprobp(P ).","We find our bound by making use of the fact that","an A∗","search never expands a node whose score","is greater than that of the goal node π∗",". Thus, a","partial solution πk is expanded only if −logprobp(π n(C) k (C)) ≤ −logprobp(π∗n(C)","(C)). Since","−logprobp(π∗n(C) (C)) ≤ −logprob p(P ), we have that πk is expanded only if −logprobp(π n(C) k (C)) ≤ −logprobp(P ). So we would like to count the number of solutions satisfying this inequality. 86","We would first like to approximate the value of −logprobp(P ), then. But, since P is drawn from an ergodic stationary distribution q, this value will approach the cross entropy H(p, q) with high probability: for any δ1, ε1 > 0, there exists an n1 > 0 such that if n(C) = n(P ) > N1, then | − logprobp(P )/n(C) − H(p, q)| < ε1 with probability at least 1 − δ1. In this case, we have that −logprobp(P ) < n(C)(H(p, q) + ε1).","Now, if k is fixed, and if πk and π′","k are two different size k partial solutions, then πk and π′","k must disagree on at least one letter assignment. Thus, the sets Πk and Π′","k must be disjoint. But then we also have that π n(C) k (C) ̸= π","n(C)′","k (C). Therefore,","if we can find an upper bound for the size of the","set","{S ∈ Σn(C) p |S = π n(C) k (C) for some πk}, we will have an upper bound on the number of times the search will expand any partial solution of size k. We note that under the previous assumptions, and with probability at least 1 − δ1, none of these strings can have a log probability larger than n(C)(H(p, q) + ε1).","For any plaintext string C drawn from q, we let aPb be the substring of P between the indices a and b. Similarly, we let aSb be the substring of S = π","n(C)","k (C) between the indices a and b. We now turn to the proof of our bound: Let","δ, ε > 0 be given. We give the following three","bounds on n:","(a) As stated above, we can choose n1 so that for any string P drawn from q with length at least n1, | − logprobp(P )/n(P ) − H(p, q)| < ε1/2 with probability at least 1 − δ/3.","(b) We have noted that if k is fixed then any two size k partial solutions must disagree on at least one of the letters that they fix. So if we have a substring aPb of P with an instance of every letter type fixed by the partial solutions of size k, then the substrings aSb of S must be distinct for every S ∈ {S ∈ Σ n(C) p |S = π n(C) k (C) for some πk}. Since q is ergodic, we can find an n2 such that for any string P drawn from q with length at least n2, every letter fixed in πk can be found in some length n2 substring P2 of P , with probability at least 1 − δ/3.","(c) By the Lemma below, there exists an n′","> 0 such that for all partial solutions πk, there exists a trigram distribution rk on the alphabet Σp such that if S = π n(C) k (C) and b − a =","n > n′",", then ∣ ∣ ∣ ∣","−logprob(aSb) n − H(p, rk) ∣ ∣ ∣ ∣ < ε/4 with a probability of at least 1 − δ/3. Let n = max(n1, n2, n′","). Then, the probability of any single one of the properties in (a), (b) or (c) failing in a string of length at least n is at most δ/3, and so the probability of any of them failing is at most δ. Thus, with a probability of at least 1−δ, all three of the properties hold for any string P drawn from q with length at least n. Let P be drawn from q, and suppose n(P ) > n. Let aPb be a length n substring of P containing a token of every letter type fixed by the size k partial solutions.","Suppose that πk is a partial solution such that −logprobp(π n(C) k (C)) ≤ n(P )(H(p, q) + ε/2).","Then, letting S = π n(C) k (C), we have that if ̨ ̨ ̨ ̨","−logprob(S) n(P )","− H(p, rk) ̨ ̨ ̨ ̨< ε/4 and ̨ ̨ ̨ ̨","−logprob(aSb) n − H(p, rk) ̨ ̨ ̨ ̨< ε/4","it follows that ̨ ̨ ̨ ̨","−logprob(S) n(P ) +","logprob(aSb) n ̨ ̨ ̨ ̨ ≤ ̨ ̨ ̨ ̨","−logprob(S) n(P ) − H(p, rk) ̨ ̨ ̨ ̨ + ̨ ̨ ̨ −̨H(p, rk) −","logprob(aSb) n ̨ ̨ ̨ ̨ ≤ ε/4 + ε/4 = ε/2 But then, −","logprob(aSb) n <","−logprob(S) n(P ) + ε/2 ≤","n(P )(H(p, q) + ε/2) n(P ) + ε/2 = H(p, q) + ε. 87 So, for our bound we will simply need to find the number of substrings aSb such that − log probp(aSb) < n(H(p, q) + ε). Letting IH (aSb) = 1 if −logprobp(aSb) < n(H(p, q) + ε) and 0 otherwise, the number of strings we need becomes","X","aS","b∈Σn(C)","p IH(aSb) = 2n·(H(p,q)+ε)X","aS","b∈Σn(C)","pIH(aSb)2−n·(H(p,q)+ε)","<2n·(H(p,q)+ε)X aS b∈Σn(C)","pIH(aSb)probp(aSb)","(since − log probp(aSb) < n(H(p, q) + ε)","implies probp(aSb) > 2−n·(H(p,q)+ε)",")","≤ 2n·(H(p,q)+ε) X aS","b∈Σn(C)","p probp(aSb) = 2n·(H(p,q)+ε) Thus, we have a bound of 2n·(H(p,q)+ε)","on the number of substrings of length n satisfying − log probp(aSb) < n(H(p, q) + ε). Since we know that with probability at least 1 − δ, these are the only strings that need be considered, we have proven our bound. □ 4.1 Lemma: We now show that for any fixed k > 0 and δ′",", ε′","> 0, there exists some n′","> 0 such that for all partial solutions πk, there exists a trigram distribution rk on the alphabet Σp such that if S = π n(C) k (C) and","b − a = n > n′ , | −logprob(aSb)","n − H(p, rk)| < ε′","with a probability of at least 1 − δ′",". Proof of Lemma: Given any partial solution πk, it will be useful in this section to consider the strings S = π","n(C)","k (C) as functions of the plaintext P rather than the ciphertext C. Since C = π−1 T (P ), then, we will compose π n(C) k and π−1","T to get π n(C)′ k (P ) = π n(C) k (π−1","T (P )). Now, since","πT is derived from a character bijection between","Σc and Σp, and since π","n(C)","k fixes the k character","types in Σc that are defined in πk, we have that","π n(C)′ k fixes k character types in Σp. Let ΣP1 be the set of k character types in Σp that are fixed by π n(C)′ k , and let ΣP2 = Σp \\ ΣP1. We note that ΣP1 and ΣP2 do not depend on which πk we use, but only on k. Now, any string P which is drawn from q can be decomposed into overlapping substrings by splitting it whenever it has see two adjacent characters from ΣP1. When we see a bigram in P of this form, say, y1y2, we split P so that both the end of the initial string and the beginning of the new string are y1y2. Note that when we have more than two adjacent characters from ΣP1 we will split the string more than once, so that we get a series of three-character substrings of P in our decomposition. As a matter of bookkeeping we will consider the initial segment to begin with two start characters s with indices corresponding to 0 and −1 in P . As an example, consider the string","P = friends, romans, countrymen, lend me your ears","Where ΣP1 = {‘ ’, ‘, ’, ‘a’, ‘y’}. In this case, we would decompose P into the strings ‘ssfriends, ’, ‘, romans, ’, ‘, countrymen, ’, ‘, lend me ’, ‘e y’, ‘ your e’ and ‘ ears’.","Let M be the set of all substrings that can be generated in this way by decomposing strings P which are drawn from q. Since the end of any string m ∈ M contains two adjacent characters in ΣP1 and since the presence of two adjacent characters in ΣP1 signals a position at which a string will be decomposed into segments, we have that the set M is prefix-free. Every string m ∈ M is a string in Σp, and so they will have probabilities probq(m) in q. It should be noted that for any m ∈ M the probability probq(m) may be different from the trigram probabilities predicted by q, but will instead be the overall probability in q of seeing the string m.","For any pair T, P of strings, let #(T, P ) be the number of times T occurs in P . Since we assume that the strings drawn from q converge to the distribution q, we have that for any δ3, ε3 > 0 and any n4 > 0, there exists an n3 > 0 such that for any substring P3 of P of length at least n3, where P is drawn from q, and for any m ∈ M of length at most n4, the number |#(m, P )/len(P3) − probq(m)| < ε3 with probability greater than 1 − δ3.","Now suppose that for some P drawn from q we have a substring aPb of P such that aPb = m, m ∈ M . If S = π","n(C)′","k (P ), consider the sub-","string aSb of S. Recall that the string function","π n(C)′ k can map the characters in P to S in one of two ways: if a character xi ∈ ΣP1 is found at index i in P , then the corresponding character in S 88 is πk(xi). Otherwise, xi is mapped to whichever character yi in ΣP maximizes the probability in p of S given π n(C)′ k (xi−2)π n(C)′ k (xi−1)yi. Since the values of π n(C)′ k (xi−2), π n(C)′ k (xi−1) and yi are in-","terdependent, and since π","n(C)′","k (xi−2) is dependent on its previous two neighbors, the value that yi takes may be dependent on the values taken by π n(C)′ k (xj) for indices j quite far from i. However, we see that no dependencies can cross over a substring in P containing two adjacent characters in ΣP1, since these characters are not transformed by π","n(C)′","k in a way that depends on their neighbors. Thus, if aPb = m ∈ M , the endpoints of aPb are made up of two adjacent characters in ΣP1, and so the substring aSb of S depends only on the substring aPb of P . Specifically, we see that aSb = π","n(C)′","k (aPb). Since we can decompose any P into overlapping substrings m1, m2, . . . , mt in M , then, we can carry over this decomposition into S to break S into π n(C)′ k (m1), π n(C)′ k (m2), . . . , π","n(C)′","k (mt). Note that the score generated by S in the A∗","search algorithm is the sum∑","1≤i≤ logprobp(yi−2yi−1yi), where yi is the ith","character in S. Also note that every three-character sequence yi−2yi−1yi occurs exactly once in the decomposition π n(C)′ k (m1), π n(C)′ k (m2), . . . , π n(C)′ k (mt). Since","for any m the number of occurrences of π","n(C)′","k (m)","in S under this decomposition will be equal to the","number of occurrences of m in P , we have that −logprobp(S) = X 1≤i≤n(P)logprobp(yi−2yi−1yi) = X","m∈M#(m, P ) · (−logprobp(πn(C)′ k (m))).","Having finished these definitions, we can now define the distribution rk. In principle, this distribution should be the limit of the frequency of trigram counts of the strings S = π n(C)′ k (P ), where n(P ) approaches infin-","ity. Given a string S = π","n(C)′","k (P ), where P","is drawn from q, and given any trigram y1y2y3","of characters in Σp, this frequency count is #(y1y2y3,S) n(P ) . Breaking S into its component substrings π n(C)′ k (m1), π n(C)′ k (m2), . . . , π","n(C)′","k (mt),","as we have done above, we see that any instance","of the trigram y1y2y3 in S occurs in exactly one of the substrings π n(C)′ k (mi), 1 ≤ i ≤ t. Grouping","together similar mis, we find","#(y1y2y3, S) n(P ) = t P i=1","#(y1y2y3, πn(C)′ k (mi)) n(P ) = P","m∈M#(y1y2y3, πn(C)′ k (m)) · #(m, P ) n(P ) As n(P ) approaches infinity, we find that #(m,P ) n(P ) approaches probq(m), and so we can write","probr k (y1y2y3) = X m∈M","#(y1y2y3, πn(C)′ k (m))probq(m). Since 0 ≤","∑ m∈M #(y1y2y3, π n(C)′ k (m))probq(m)","when P is sampled from q we have that X","y 1y 2y 3probr","k (y1y2y3) = X y 1y 2y","3 X","m∈M#(y1y2y3, πn(C)′ k (m))probq(m) = lim n(P)→∞ X y 1y 2y","3 X","m∈M#(y1y2y3, πn(C)′ k (m)) #(m, P ) n(P ) = lim n(P)→∞ X m∈M X","y 1y 2y 3#(y1y2y3, πn(C)′","k (m)) #(m, P ) n(P ) = lim n(P)→∞ X m∈M","(n(πn(C)′ k (m)) − 2)#(m, P )","n(P ) = lim n(P)→∞ X m∈M","(n(m) − 2)#(m, P ) n(P ) = lim n(P)→∞ n(P ) n(P ) = 1, so we have that probrk is a valid probability distribution. In the above calculation we can rearrange the terms, so convergence implies absolute convergence. The sum","∑ y1y2y3 #(y1y2y3, π n(C)′ k (m)) gives (n(π n(C)′ k (m)) − 2) because there is one","trigram for every character in π","n(C)′","k (m), less two to compensate for the endpoints. However, since the different m overlap by two in a decomposition from P , the sum (n(m) − 2)#(m, P ) just gives back the length n(P ), allowing for the fact that the initial m has two extra start characters. Having defined rk, we can now find the value of H(p, rk). By definition, this term will be 89 X","y 1y 2y 3−logprobp(y1y2y3)probr","k (y1y2y3) = X y 1y 2y","3−logprobp(y1y2y3)X","m∈M#(y1y2y3, πn(C)′ k (m))probq(m) = X m∈M X","y 1y 2y 3−logprobp(y1y2y3)#(y1y2y3, πn(C)′","k (m))probq(m) = X m∈M−logprobp(m)probq(m).","Now, we can finish the proof of the Lemma. Holding k fixed, let δ′",", ε′","> 0 be given. Since we have assumed that p does not assign a zero probability to any trigram generated by q, we can find a trigram x1x2x3 generated by q whose probability in p is minimal. Let X = −logprobp(x1x2x3), and note that probp(x1x2x3) > 0 implies X < ∞. Since we know by the argument above that when P is sampled from q, limn(P )→∞(","∑ m∈M","(nπn(C)′ k (m)−2)·#(m,P )","n(P ) ) = 1, we have that ∑ m∈M (nπ n(C)′ k (m) − 2)probq(m) = 1. Thus, we can choose n4 so that ∑ m∈M,n(m)≤n4 (nπ n(C)′ k (m) − 2)probq(m)","> 1 − ε′ /4X. Let Y = |{m ∈ M, n(m) ≤ n4}|, and choose n′","such that if P is sampled from q and","aPb is a","substring of P with length greater than n′",", then","with probability at least 1 − δ′",", for every m ∈ M","we will have that ̨ ̨ ̨ ̨ #(m, aPb) n(aPb)","− probq(m) ̨ ̨ ̨ ̨< ε′","/4XY (n4 − 2). Let πk be any partial solution of length k, and let rk be the trigram probability distribution described above. Then let P be sampled from q, and let S = π n(C) k (C) = π n(C)′ k (P ), and let a, b be indices of","S such that b − a = n > n′",". Finally, we will","partition the set M as follows: we let M ′","be the","set {m ∈ M |n(n) ≤ n4} and M ′′","be the set {m ∈","M |n(m) > n4}. Thus, we have that ̨ ̨ ̨ ̨","−logprob(aSb) n − H(p, rk) ̨ ̨ ̨ ̨ = ̨ ̨ ̨ ̨ ̨","P m∈M #(m, aPb)(−logprobp(πn(C)′","k (m)) n − X m∈M","probq(m) · (−logprobp(πn(C)′ k (m)) ̨ ̨ ̨ ̨ ̨ .","Grouping the terms of these sums into the index","sets M ′","and M ′′",", we find that this value is at most ̨ ̨ ̨ ̨ ̨ X m∈M′ „","#(m, aPb) n","− probq(m)« (−logprobp(πn(C)′","k (m)) ̨ ̨ ̨ ̨ ̨ + ̨ ̨ ̨ ̨ ̨ X m∈M′′ „ #(m, aPb)","n − probq(m)«","(−logprobp(πn(C)′ k (m)) ̨ ̨ ̨ ̨ ̨ Furthermore, we can break up the sum over the index M ′′","to bound this value by ̨ ̨ ̨ ̨ ̨ X m∈M′ „ #(m, aPb)","n − probq(m)«","(−logprobp(πn(C)′ k (m)) ̨ ̨ ̨ ̨ ̨ + ̨ ̨ ̨ ̨ ̨ X m∈M′′","#(m, aPb) n","(−logprobp(πn(C)′ k (m)) ̨ ̨ ̨ ̨ ̨ + ̨ ̨ ̨ ̨ ̨ X","m∈M′′probq(m)(−logprobp(πn(C)′ k (m)) ̨ ̨ ̨ ̨ ̨ Now, for any m ∈ M , we have that the score −logprobp(π n(C)′ k (m) equals","∑ 1≤i≤n(m)−2 −logprobp(yiyi+1yi+2), where yi is the character at the index i in π","n(C)′","k (m). Taking the maximum possible values for −logprobp(yiyi+1yi+2), we find that this sum is at most (n(m) − 2)X. Applying this bound to the previous formula, we find that it is at most ̨ ̨ ̨ ̨ ̨ X m∈M′ „","#(m, aPb) n − probq(m)« (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ + ̨ ̨ ̨ ̨ ̨ X m∈M′′","#(m, aPb) n (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ + ̨ ̨ ̨ ̨ ̨ X m∈M′′probq(m) · (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ . We can bound each of these three terms separately. Looking at the first sum in this series, we find that with probability at least 1 − δ′",", 90 ̨ ̨ ̨ ̨ ̨ X m∈M′ „","#(m, aPb) n","− probq(m)« (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ (*) ≤ X m∈M′ ̨ ̨ ̨ ̨","#(m, aPb) n","− probq(m) ̨ ̨ ̨ ̨(n(m) − 2)X ≤ X m∈M′ ̨ ̨ ̨ ̨","ε′ 4(n4 − 2)XY ̨ ̨ ̨ ̨· (n(m) − 2)X ≤ X m∈M′ ̨ ̨ ̨ ̨ ε′ 4Y ̨ ̨ ̨ ̨ = ε′ 4Y X m∈M′1 = ε′ 4Y Y = ε/4. In order to bound the second sum, we make use of the fact that ∑","m∈M #(m, aPb)(n(m) − 2) =","n(aPb) = n to find that once again, with probabil-","ity greater than 1 − δ′",", ̨ ̨ ̨ ̨ ̨ X m∈M′′","#(m, aPb) n (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ ≤ X m∈M′′ ̨ ̨ ̨ ̨","#(m, aPb) n (n(m) − 2)X ̨ ̨ ̨ ̨.","Since M ′′ = M − M ′",", this value is X m∈M ̨ ̨ ̨ ̨","#(m, aPb) n (n(m) − 2)X ̨ ̨ ̨ ̨ − X m∈M′ ̨ ̨ ̨ ̨","#(m, aPb) n (n(m) − 2)X ̨ ̨ ̨ ̨ =X − X m∈M′ ̨ ̨ ̨ #̨(m, aPb)","n (n(m) − 2)X ̨ ̨ ̨ ̨. This value can further be split into =X − X m∈M′ ̨ ̨ ̨ ̨ „","#(m, aPb) n","+(1−1)probq(m)« (n(m)−2)X ̨ ̨ ̨ ̨ ≤X −  X m∈M′ |probq(m)(n(m) − 2)X| − X m∈M′ ̨ ̨ ̨ ̨","#(m, aPb) n − probq(m) ̨ ̨ ̨ ̨(n(m) − 2)X ! Using our value for the sum in (*), we find that this is =X − X m∈M′ |probq(m)(n(m) − 2)X| + X m∈M′ ̨ ̨ ̨ ̨","#(m, aPb) n − probq(m) ̨ ̨ ̨ ̨(n(m) − 2)X ≤X − X m∈M′ |probq(m)(n(m) − 2)X| + ε′ 4 , Using our definition of n4, we can further bound this value by =X  1 − X m∈M′ probq(m)(n(m) − 2) ! + ε′ 4 <X „ 1 − „ 1 − ε′ 4X «« + ε′ 4 =X ε′ 4X + ε′ 4 = ε′ 2 . Finally, we once again make use of the definition of n4 to find that the last sum is ̨ ̨ ̨ ̨ ̨ X m∈M′′probq(m) · (n(m) − 2)X ̨ ̨ ̨ ̨ ̨ = X m∈M′′probq(m) · (n(m) − 2)X = X X m∈M′′probq(m) · (n(m) − 2) < X ε′ 4X = ε′ 4 .","Adding these three sums together, we get ε′ 4 + ε′ 2 + ε′ 4","= ε′ . Thus, ∣ ∣ ∣","−logprob(aSb) n − H(p, rk) ∣ ∣ ∣ < ε′","with prob-","ability greater than 1 − δ′",", as required. □"]},{"title":"5 Conclusion","paragraphs":["In this paper, we discussed a discrepancy between the theoretical and practical running times of certain algorithms that are sensitive to the entropies of their input, or the entropies of the distributions from which their inputs are sampled. We then used the algorithm from Corlett and Penn (2010) as a subject to allow us to investigate ways to talk about average-case complexity in light of this discrepancy. Our analysis was sufficient to give us a bound on the search complexity of this algorithm which is exponential in the cross-entropy between the training distribution and the input distribution. Our method in effect yields a probabilistic bound on the depth of the search heuristic used. This leads to an exponentially smaller search space for the overall problem.","We must note, however, that our analysis does not fully reconcile the discrepancy between the 91 theoretical and practical running time for this algorithm. In particular, our bound still does not explain why the number of search nodes expanded by this algorithm tends to converge on one per partial solution size as the length of the string grows very large. As such, we are interested in further studies as to how to explain the running time of this algorithm. It is our opinion that this can be done by refining our description of the sets Πk to exclude strings which cannot be considered by the algorithm. Not only would this allow us to reduce the overall number of strings we would have to count when determining the bound, but we would also have to consider fewer strings when determining the value of n′",". Both changes would reduce the overall complexity of our bound.","This general strategy may have the potential to illuminate the practical time complexities of approximate search algorithms as well."]},{"title":"References","paragraphs":["David Arthur, Bodo Manthey, and Heiko Röglin. k-means has polynomial smoothed complexity. In The 50th","Annual Symposium on Foundations of Computer Science. IEEE Computer Society Technical Committee on Mathematical Foundations of Computing, 2009. URL http: //arxiv.org/abs/0904.1113.","Eric Corlett and Gerald Penn. An exact A∗","method for deciphering letter-substitution ciphers. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1040–1047, 2010.","Richard E Korf and Michael Reid. Complexity analysis of admissible heuristic search. In Proceedings of the Fifteenth National Conference on Artificial Intelligence, 1998.","Richard E Korf, Michael Reid, and Stefan Edelkamp. Time complexity of iterativedeepening-A∗",". Artificial Intelligence, 129(1–2): 199–218, 2001.","Judea Pearl. Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley, 1984.","Daniel A Spielman and Shang-Hua Teng. Smoothed analysis of algorithms: Why the simplex algorithm usually takes polynomial time. Journal of the ACM, 51(3):385–463, 2004. 92"]}]}