{"sections":[{"title":"","paragraphs":["Proceedings of the 11th International Conference on Finite State Methods and Natural Language Processing, pages 63–71, St Andrews–Sctotland, July 15–17, 2013. c⃝2013 Association for Computational Linguistics"]},{"title":"Finite State Methods and Description Logics Tim Fernando Trinity College Dublin, Ireland Tim.Fernando@tcd.ie Abstract","paragraphs":[". The accepting runs of a finite automaton are represented as concepts in a Description Logic, for various systems of roles computed by finite-state transducers. The representation refines the perspective on regular languages provided by Monadic Second-Order Logic (MSO), under the Büchi-Elgot-Trakhtenbrot theorem. String symbols are structured as sets to succinctly express MSO-sentences, with auxiliary symbols conceived as variables bound by quantifiers."]},{"title":"1 Introduction","paragraphs":["As declarative specifications of sets of strings accepted by finite automata (i.e. regular languages), regular expressions are far and away more popular than the formulas of Monadic Second-Order Logic (MSO), which, by a fundamental theorem due to Büchi, Elgot and Trakhtenbrot, pick out the regular languages (e.g. Thomas, 1997). Computational semantics, however, can hardly ignore MSO’s model-theoretic perspective on strings with its computable notions of entailment. Furthermore, regular expressions lack the succinctness that MSO’s Boolean connectives support. Both negation and conjunction blow up the size of regular expressions by an exponential or two (Gelade and Neven, 2008). A symptom of the problem is the exponential cost of mapping a finite automaton A to a regular expression denoting the language L(A) accepted by A (Ehrenfeucht and Zeiger, 1976; Holzer and Kutrib, 2010). A more economical declarative representation of L(A) is afforded by pairing a string a1a2 · · · an in L(A) with a string q1q2 · · · qn of A’s (internal) states qi in the course of a run (by A) accepting a1a2 · · · an. This representation involves expanding the alphabet of the strings, and subsequently contracting the alphabet. A simple way to carry this out is by forming strings α1α2 · · · αn of sets αi that we can, for instance, intersect with a fixed set B, defining a string homomorphism ρB for componentwise intersection with B ρB(α1 · · · αn) := (α1 ∩ B) · · · (αn ∩ B). For example, assuming no state qi belongs to the alphabet Σ of L(A), ρΣ( a1, q1 · · · an, qn ) = a1 · · · an where we draw boxes instead of curly braces for sets used as string symbols.","The homomorphisms ρB are linked below to the treatment of variables in MSO. Given a finite alphabet A, MSOA-sentences are formed from a binary relation symbol S (encoding successor) and a unary relation symbol Ua, for each a ∈ A. We then interpret an MSOA-sentence against a string over the alphabet 2A","of subsets of A, deviating ever so slightly from the custom of interpreting against strings in A+",". Expanding the alphabet from A to 2A","accommodates a form of underspecification that, among other things, facilitates the interpretation of MSOA-formulas relative to variable assignments. As for the homomorphisms ρB, the idea is that B picks out a subset of A, leaving each a ∈ A that is not in B as an “auxiliary marker symbol” — a staple of finite-state language processing (Beesley and Karttunen, 2003; Yli-Jyrä and Koskenniemi, 2004; Hulden, 2009).","By focusing on the accepting runs of a finite automaton, the present paper strives to be relevant to finite-state language processing in general. But to understand its difference with say (Hulden, 2009), a few words about the language applications motivating it might be helpful. These applications concern not morphology, phonology, speech or even syntax but semantics — in particular, temporal semantics. The convenience of equating succession in a string with temporal succession is yet another 63","reason to step from A up to 2A","(reading a boxed","subset of A as a snapshot). It is a trivial enough","matter to build a finite-state transducer between","(2A",")∗","and (A ∪ {[, ]})∗","unwinding say, the string","a, a′ a′ of length 2 over the alphabet 2{a,a′","} to the string","[aa′ ][a′ ] of length 7 over the alphabet {a, a′",", [, ]} and if we are to apply ρB, it is natural to choose the alphabet 2A","over A ∪ {[, ]}. There are, in any case, many more regular relations apart from ρB to consider for temporal semantics (Fernando, 2011), including those that change string length and the notion of temporal succession, i.e. granularity. A simple but powerful way of building a regular language from a regular relation R is by forming the inverse image of a regular language L under R, which we write ⟨R⟩L, following dynamic logic (e.g. Fischer and Ladner, 1979). The basic thrust of the present paper is to extend regular expressions by adding connectives for negation, conjunction and inverse images under certain regular relations.","This extension is dressed up below in Description Logic (DLs; Baader et al. 2003), with the languages L(A) accepted by automata A as DL-concepts (unary relations), and various regular relations including ρB (for different sets B) as DL-roles (binary relations). As in the attributive language with complement ALC, DL-concepts C are closed under conjunction C ∧ C′",", negation ¬C, and inverse images under DL-roles R, the usual DL notation for which, (∃R)C, we replace by ⟨R⟩C from dynamic logic, with","[[⟨R⟩C]] := {s | (∃s′ ∈ [[C]]) s[[R]]s′","}. Since DL-concepts and DL-roles in the present context, have clear intended interpretations, we will often drop the semantic brackets [[·]], conflat-ing an expression with its meaning.","MSO is linked to DL by a mapping of MSO-sentences φ to DL-concepts Cφ that reduces MSO-entailments |=MSO to concept inclusion φ |=MSO ψ ⇐⇒ Cφ ⊆ Cψ . (1) Let us take care not to read (1) as stating MSO is interpretable in DL in the sense of (Tarski et al., 1953); no formal DL theory is mentioned in (1), only a particular (intended) interpretation over strings. What we vary is not the interpretation [[·]] but the mapping φ ↦→ Cφ establishing (1). Many different definitions of Cφ will do, and the main aim of the present work is to explore these possibilities, expressed as particular DL concepts and roles. In its account of regular languages, the Büchi-Elgot-Trakhtenbrot theorem says nothing about finite-state transducers, which are nonetheless instrumental in establishing the theorem. Behind the move to Description Logics is the view that the role of finite-state transducers in construct-ing regular languages merits scrutiny.","To dispel possible confusion, it is perhaps worth remarking that a relation computable by a finite-state transducer may have a transitive closure that no finite-state transducer can compute. A simple example is the function f that leaves all strings unchanged except those of the form 1n","0m+2","2k which it maps to 1n+1","0m","2k+1",". The intersection","1∗","2∗ ∩ {f k","(0n",") | k, n ≥ 0} is the non-regular language {1n","2n","| n ≥ 0}, precluding a finite-state transducer from computing the transitive closure of f . Commenting on the Description Logic counterpart ALCreg to Propositional Dynamic Logic (Fischer and Ladner, 1979), Baader and Lutz write many of today’s most used concept languages do not include the role constructors of ALCreg. The main reason is that applications demand an implementation of description logic reasoning, and the presence of the reflexive-transitive closure constructor makes obtaining efficient implementations much harder. There should be no mistaking the interpretations of concepts and roles below for models of ALCreg. Most every role considered below (from ρB on) is, however, transitive and indeed can be viewed as some notion of “part of.”","The remainder of this paper is organized as follows. The accepting runs of a finite automaton are expressed as a DL-concept in section 2. This is then used to present MSO’s semantic set-up in section 3. A feature of that set-up is the expansion of MSOA-models from A+","to (2A",")+",", opening up possibilities of underspecification which section 4 explores alongside non-deterministic DL-roles (in addition to the inverse of ρB). Section 64 5 looks at more DL-roles that, unlike ρB, change length, and section 6 concludes, returning to auxiliary symbols, which are subject not only to ρB but the various regular relations formulated above as DL-roles."]},{"title":"2 Accepting runs as a DL-concept","paragraphs":["One half of the aforementioned Büchi-Elgot-Trakhtenbrot theorem turns finite automata to MSO-sentences. This section adapts the idea behind that half in a DL setting, deferring details about MSO to the next section. An accepting run of a finite automaton A is a string a1, q1 a2, q2 · · · an, qn such that q0 a1 q1 a2 q2 a3 · · · an qn ∈ F where q0 is A’s initial state, is A’s set of transitions (labeled by symbols), and F is A’s set of final/accepting states. (Note A may be identified with such a triple ⟨, q0, F ⟩.) Let us assume that A’s set Q of states is disjoint from the alphabet Σ, and treat ai, qi as a 2-element subset of Σ ∪ Q, making an accepting run a string over the alphabet 2Σ∪Q","of subsets of Σ ∪ Q. Clearly, for any finite automaton A, the set AccRuns(A) of accepting runs of A is regular — simply modify A’s transitions to","{(q, a, q′",", q′ ) | q a","q′","} . The language L(A) accepted by A can then be formed applying ρΣ to A’s accepting runs (setting aside the cosmetic difference between a and a)","L(A) ≈ {ρΣ(s) | s ∈ AccRuns(A)} = ⟨ρΣ−1","⟩ AccRuns(A) . It remains to express the language AccRuns(A) through conjunctions and negations of a small number of languages ⟨R⟩L for certain (particularly simple) choices of R and L. One such R is componentwise inclusion between strings of sets of the same length := {(α1 · · · αn, β1 · · · βn) | αi ⊇ βi for 1 ≤ i ≤ n} (Fernando, 2004). For example, s ρB(s) for all strings s of sets, and α for all sets α. Returning to AccRuns(A), let us collect","(i) strings with final position containing an A-final state in LF := ⟨⟩ ∑ q∈F","∗ q","(ii) strings whose first position contains a pair a, q such that q0 a q in Lq0 := ⟨⟩ ∑ q0 a q a, q ∗ and","(iii) (bad) strings containing q a, q′",", for some triple (q, a, q′",") ∈ Q × Σ × Q outside the set of transitions in L̸ := ⟨⟩ ∑ q̸ a q′ ∗ q a, q′ ∗ Also, for any set B, let Spec(B) be the set Spec(B) := ⟨ρB⟩( ∑ b∈B b )∗ of strings with exactly one element of B in each string position. Proposition 1. Let A be a finite automaton with transitions ⊆ Q × Σ × Q, final states F ⊆ Q and initial state q0, The set AccRuns(A) − {ε} of non-null accessible runs of A is Spec(Σ) ∩ Spec(Q) ∩ LF ∩ Lq0 − L̸","intersected with the set (2Σ∪Q",")∗","of strings over the","alphabet 2Σ∪Q of subsets of the finite set Σ ∪ Q.","Given any finite set A, the restrictions to (2A",")∗","of","the relations ρB and","ρA","B := ρB ∩ ((2A )∗ × (2A",")∗",")","A := ∩ ((2A",")∗ × (2A",")∗",") are computable by finite-state transducers. That is, the intersection mentioned in Proposition 1 with (2Σ∪Q",")∗","can be built into the relations ρΣ, ρQ and for a characterization of AccRuns(A) as well as L(A) within a description logic, all concepts in which are regular languages, and all roles in which are computable by finite-state transducers (keeping ⟨R⟩L regular). The obvious question is how that characterization compares with MSO, to which we turn next. 65"]},{"title":"3 MSO-models and reducts from ρ","paragraphs":["B Given a finite set A, let us agree that an MSOA-model M is a tuple ⟨[n], Sn, {[[Ua]]}a∈A⟩ for some positive integer n > 0,1","where","(i) [n] is the set {1, 2 . . . , n} of positive integers from 1 to n","(ii) Sn is the relation encoding the successor/next relation on [n] Sn := {(i, i + 1) | i ∈ [n − 1]} and for each a ∈ A,","(iii) [[Ua]] is a subset of [n] interpreting the unary relation symbol Ua. We can form MSOA-models from strings over the alphabets A and (2A",") as follows. Given a string s = a1a2 · · · an ∈ An",", let Mod(s) be the MSO","A-model ⟨[n], Sn, {[[Ua]]}a∈A⟩ interpreting Ua as the set of string positions i occupied by a [[Ua]] = {i ∈ [n] | ai = a}","for each a ∈ A. Expanding the alphabet A to 2A",",","a string α1α2 · · · αn ∈ (2A )n","induces the MSO","A-model ⟨[n], Sn, {[[Ua]]}a∈A⟩ interpreting Ua as the set of positions i filled by boxes containing a [[Ua]] = {i ∈ [n] | a ∈ αi} for each a ∈ A. Conversely, given an MSOA-model M = ⟨[n], Sn, {[[Ua]]}a∈A⟩, let str(M ) be the string α1 · · · αn ∈ (2A",")n","where αi := {a ∈ A | i ∈ [[Ua]]} . That is, for all a ∈ A and i ∈ [n], a ∈ αi ⇐⇒ i ∈ [[Ua]]","making the map M ↦→ str(M ) a bijection between","MSOA-models and (2A",")+",". Proposition 2. Given an MSOA-model M , the following are equivalent. (i) M is Mod(s) for some s ∈ A+","1","There is, of course, a rich theory of infinite MSO-models, given by infinite strings (e.g. Thomas, 1997). We focus here on finite models/strings, which suffice for many applications; more in section 6 below. (ii) M satisfies the MSOA-sentence (∀x) ∨ a∈A (Ua(x) ∧ ∧ a′ ∈A−{a} ¬Ua′(x)) (saying the non-empty [[Ua]]’s partition the universe) (iii) str(M ) ∈ Spec(A)","(iv) str(M ) = a1 · · · an for some a1 · · · an ∈ A+",". While the Büchi-Elgot-Trakhtenbrot theorem (BET) concerns MSOA-models Mod(s) given by strings s ∈ A+",", the wider class of MSOA-models (isomorphic to (2A",")+",") is useful for encoding variable assignments crucial to the second half of BET, asserting the regularity of MSO-sentences. More precisely, the remainder of this section is devoted to defining regular languages LA(φ) for MSOA-sentences φ establishing Proposition 3. For every MSOA-sentence φ, there is a regular language LA(φ) such that for every MSOA-model M , M |= φ ⇐⇒ str(M ) ∈ LA(φ). Insofar as the models Mod(s) given by strings s ∈ A+","differ from those given by strings over (2A",") via str−1",", Proposition 3 differs from the half of BET saying MSO-sentences define regular languages. There is no denying, however, that the difference is slight.","Be that as it may, I claim the expansion of A to 2A","leads to a worthwhile simplification, as can be seen by proving Proposition 3 as follows. Given a positive integer n, an n-variable assignment f is a function whose domain is a finite set Var = Var1 ∪ Var2 of first-order variables x ∈ Var1 that f maps to an integer f (x) ∈ [n] and second-order variables X ∈ Var2 that f maps to a set f (X) ⊆ [n]. Then if M is a MSOA-model over [n], M, f |= Ua(x) ⇐⇒ f (x) ∈ [[Ua]] and M, f |= X(x) ⇐⇒ f (x) ∈ f (X). 66 We can package the pair M, f as the MSOA∪V ar-model M f","over [n] identical to M on U a’s for a ∈ A, with interpretations [[UX ]] = f (X) for X ∈ Var2 [[Ux]] = {f (x)} for x ∈ Var1. Note [[Ux]] intersects [[UX ]] if M, f |= X(x), which is to say X(x) entails the negation of spec({X, x}), where spec(A) is the MSOA-sentence that Proposition 2 mentions in (ii) (∀x) ∨ a∈A (Ua(x) ∧ ∧ a′ ∈A−{a} ¬Ua′(x)). In other words, to treat a pair M, f as an MSOA∪V ar-model (and an MSOA-formula φ with free variables in Var as an MSOA∪V ar-sentence), the step from A to 2A","is essential. Turning model expansions around, given B ⊆ A, we define the B-reduct of an MSOA-model M to be the MSOB-model MB obtained from M after throwing out all interpretations [[Ua]] for a ∈ A − B. It is easy to see that the homomorphisms ρB yield B-reducts: str(MB) = ρB(str(M )) (for all MSOA-models M ). Proceeding now to the languages LA(φ) in Proposition 3, observe that we can picture Ua(x) as the language","L(a, x) := ( + a )∗ a, x ( + a )∗ inasmuch as","M, f |= Ua(x) ⇐⇒ ρA∪V ar {a,x} (str(M f",")) ∈ L(a, x).","For the remainder of this section, let A′","⊆ A∪Var.","We put, for a, x ∈ A′",",","LA′(Ua(x)) := ⟨ρA′","{a,x}⟩ L(a, x).","Similarly, for X, x ∈ A′ , let L A′(X(x)) be","⟨ρA′ {X,x}⟩ ( + X )∗","X, x ( + X )∗","and for x, y ∈ A′",",","LA′(x = y) := ⟨ρA′ {x,y}⟩ ∗","x, y ∗","LA′(S(x, y)) := ⟨ρA′ {x,y}⟩ ∗","x y ∗",". We also put","LA′(φ ∧ ψ) := LA′(φ) ∩ LA′(ψ) LA′(¬φ) := (2A′",")+ − L A′(φ).","As for quantification, for v ∈ Var, let σA′ v be the","inverse of ρA′ ∪{v} A′ ,2","and set","LA′(∃X.φ) := ⟨σA′ X ⟩ LA′","∪{X}(φ)","LA′(∃x.φ) := ⟨σA′ x ⟩ (LA′","∪{x}(φ) ∩","LA′ ∪{x}(x = x)) where the intersection with LA′","∪{x}(x = x) in-sures that x is treated as a first-order variable in φ (occurring in exactly one string position).","Taking stock, to define the regular language LA(φ) required by Proposition 3 for an MSOA-sentence φ with variables from a finite set Var of variables, we form ALC-concepts from (i) the primitive concepts","L(a, x), L(X, x),","∗","x, y ∗ , ∗","x y ∗",", (2B",")+ for a ∈ A and x, X, y ∈ Var and B ⊆ A ∪ Var, and (ii) the roles ρA′ B , σA′","v","for B ⊆ A′","⊆ A ∪ Var and v ∈ Var."]},{"title":"4 B-specified strings and containment ⊒","paragraphs":["Recall that spec(B) is the MSOB-sentence saying every string position has exactly one symbol from B (∀x) ∨ b∈B (Ub(x) ∧ ∧ b′ ∈B−{b} ¬Ub′(x)) and observe that there is no trace of σA","x or complementation or intersection (interpreting ¬∃x and ∧) in the language","SpecA(B) := ⟨ρA B⟩( ∑ b∈B b )∗ of strings encoding MSOA-models satisfying spec(B), for B ⊆ A. That is, although SpecA(B) and LA(spec(B)) from the previous section specify the same set of strings, they differ as expressions, suggesting different automata. Section 2 provides yet more expressions for automata, draw-ing on a different pool of primitive concepts and roles.","2","We could instead move the inverse out of the relation R, allowing ⟨R⟩ to go not only to the left of L as in ⟨R⟩L but also to its right for the image L⟨R⟩ of L under R. 67","In addition to componentwise inclusion (a non-deterministic generalization of the functions ρB that dispenses with the subscript B), it is useful to define relations between strings of different lengths, including those that pick out prefixes","prefixA := {(ss′",", s) | s, s′ ∈ (2A",")∗","} and suffixes","suffixA := {(ss′",", s′",") | s, s′","∈ (2A",")∗","}. Leaving out the subscripts A = Σ ∪ Q for notational simplicity, we can describe three of the languages in Proposition 1 (section 2) as LF = ⟨⟩⟨suffix⟩ ∑ q∈F q Lq0 = ⟨⟩⟨prefix⟩ ∑ q0 a q a, q L̸ = ⟨⟩⟨suffix⟩⟨prefix⟩ ∑ q̸ a q′ q a, q′ zeroing in on the substrings of length ≤ 2 that are of interest. It is convenient to abbreviate ⟨⟩⟨suffix⟩⟨prefix⟩L (equivalently, ⟨⟩ ∗","L ∗",")) to ⟨⊒⟩L , effectively defining containment ⊒ to be the relational composition of componentwise inclusion with suffix and prefix ⊒ := ; suffix ; prefix (and ⊒A as A; suffixA; prefixA). Writing EA(x) for the set EA(x) := LA(x = x)","of strings in (2A",")+","in which x occurs exactly once,","we have LA(Ua(x)) = EA(x) ∩ ⟨⊒⟩ a, x LA(X(x)) = EA(x) ∩ ⟨⊒⟩ X, x LA(x = y) = EA(x) ∩ EA(y) ∩ ⟨⊒⟩ x, y LA(S(x, y)) = EA(x) ∩ EA(y) ∩ ⟨⊒⟩ x y and apart from EA(x), primitive concepts given by strings of length ≤ 2 will do. The locality (in such short strings) is obscured in our ρA","B-based analysis of LA(φ) in the previous section, under which","EA(x) = ⟨ρA {x}⟩ ∗","x ∗","= ⟨⊒A⟩ x − ⟨⊒⟩ x ∗","x . (2) An existence predicate of sorts, EA(x) is presuppositional in the same way for MSO that SpecA(B) is for the accepting runs of finite automata; EA(x) and SpecA(B) are general, nonlocal background requirements imposed indiscriminately on models and automata, in contrast to assertions (in the foreground) that focus on short substrings, picking out specific models and automata.","An instructive test case is provided by the transitive closure < of S; an MSO{x,y}-sentence saying that x < y is ∃X ((∀u, v)(X(u) ∧ S(u, v) ⊃ X(v)) ∧ X(y) ∧ ¬X(x)). Second-order quantification aside, the obvious picture to associate with x < y is x ∗","y , which is built into the representation","LA(x < y) = EA(x) ∩ EA(y)∩ ⟨⊒⟩ x ∗","y (3) of MSOA-models satisfying x < y (with x, y ∈ A). In both lines (2) and (3) above, arbitrarily long substrings from ∗","occur, that we will show how to compress next."]},{"title":"5 Intervals and compression","paragraphs":["Given e ∈ A, we can state that the set [[Ue]] represented by a symbol e ∈ A is an interval through the MSO{e}-sentence ∃x Ue(x) ∧ ¬∃y gape(y) (4) where gape(y) abbreviates the MSO{e,y}-sentence ¬Ue(y) ∧ ∃u∃v (u < y ∧ y < v ∧ Ue(u) ∧ Ue(v)). We can translate (4) into a regular language, applying the recipes above. But a more concise and perspicuous representation is provided by defining a function bc that compresses a string s as follows. Let bc(s) compress blocks βn","of n > 1 consecutive occurrences in s of the same symbol β to a single β, leaving s otherwise unchanged bc(s) :=   ","bc(βs′",") if s = ββs′","α bc(βs′",") if s = αβs′","with α ̸= β","s otherwise. For example, bc( e e e, y e ) = e e, y e 68 and in general, bc outputs only stutter-free strings, where a string β1β2 · · · βn is stutter-free if βi ̸= βi+1 for i from 1 to n − 1. Observe that [[Ue]] is an interval precisely if bc(ρ{e}(str(M ))) ∈ ( + ε) e ( + ε). Compressing further, we can delete initial and final empty boxes through unpad unpad(s) :=   ","unpad(s′ ) if s = s′","or","else s = s′","s otherwise","and collect all strings in (2A",")+","representing","MSOA-models in which e is an interval in","IntervalA(e) := ⟨ρA {e}⟩⟨bc⟩⟨unpad⟩ e .","Defining πA B to be the composition of ρA","B with bc and unpad πA B(s) := unpad(bc(ρA","B(s))) we have","IntervalA(e) = ⟨πA {e}⟩ e and, as promised at the end of section 4, we can eliminate ∗","from (2)","EA(x) = ⟨πA {x}⟩ x − ⟨⊒⟩ x x and from (3) LA(x < y) = EA(x) ∩ EA(y) ∩ ⟨π{x,y}⟩ ( x y + x y ) (dropping the superscript A on πA","B when possible). Stepping from one interval e to a finite set E of such, let","Interval(E) := {πE","E (s) | (∀e ∈ E)","πE","{e}(s) = e }","= ⟨unpad−1 ⟩⟨bc−1","⟩ ⋂ e∈E","⟨πE {e}⟩ e so that Interval({e}) = e , and for e ̸= e′",", the set Interval({e, e′","}) consists of thirteen strings, one per interval relation in (Allen, 1983). We can or-ganize these strings as follows (Fernando, 2012). For any finite set E, a string s ∈ Interval(E) determines a triple ⟨E, ⃝s, ≺s⟩ with binary relations on E of overlap e ⃝s e′","when πE","{e,e′","}(s) is one of the nine strings in Interval({e, e′","}) that contain the pair e, e′","⃝s := {(e, e′",") | πE {e,e′","}(s) ∈ ( e + e′","+ ε)","e, e′ ( e + e′","+ ε)}","and precedence e ≺s e′","when πE","{e,e′","}(s) is either","e e′ or e e′","≺s := {(e, e′",") | πE","{e,e′","}(s) ∈ e e′","+ e e′","} leaving the two other strings in Interval({e, e′","}) for e′","≺s e. The triple ⟨E, ⃝s, ≺s⟩ satisfies the axioms for an event structure in the sense of (Kamp and Reyle, 1993), and conversely, every such event structure over E can be obtained as ⟨E, ⃝s, ≺s⟩ for some s ∈ Interval(E)."]},{"title":"6 Discussion: simplifying where possible","paragraphs":["Few would argue against representing information as simply as possible. Among strings, there is nothing simpler than the null string ε, and ε is the starting point for refinements given by the system of string functions πA","B insofar as","ε = πA B(α1 · · · αn) for all α1 · · · αn ∈ (2A",")∗ such that B ∩ n ⋃ i=1 αi = ∅ .","We have taken pains above to motivate the con-","struction of πA","B := ρA","B; bc; unpad from","(i) ρA B, linked in section 3 to MSO and regular languages via the Büchi-Elgot-Trakhtenbrot theorem and from","(ii) bc and unpad, linked in section 5 to event structures for the Russell-Wiener construc-tion of temporal moments from events (or temporal intervals). A familiar example is provided by a calendar year, represented as the string yearmo := Jan Feb · · · Dec of length 12, one box per month from the set mo := {Jan, Feb, Mar, . . ., Dec}. A finer-grained representation is given by the string yearmo,dy := Jan,d1 Jan,d2 · · · Jan,d31 Feb,d1 · · · Dec,d31 69 of length 365, one box per day, featuring unordered pairs from mo and dy := {d1, d2, . . ., d31}. As the homomorphisms ρA","B see only what is in B, ρmo∪dy mo (yearmo,dy) = Jan 31 Feb 28 · · · Dec 31 which π mo∪dy mo then compresses to bc( Jan 31 Feb 28 · · · Dec 31 ) = yearmo making π","mo∪dy","mo (yearmo,dy) = yearmo. If ρA","B provides the key to establishing the regularity of MSO-formulas, block compression bc captures the essence of the slogan ”no time without change” behind the Russell-Wiener conception of time. Whereas ρA","B limits what can be observed to what is in B, bc minimizes the time (space) over which to make these observations. Note that there are finite-state transducers that compute ρA","B and bc (over a finite alphabet). Thus, we may form the inverse image of a regular language under either ρA","B or bc without worrying if the result is still regular. (It is.)","Were we to leave unpad out and make do with bcA B := ρA","B; bc, we need only start our bcA","B-based refinements from the string of length one consisting of the empty set (rather than ε, as in the case of πA","B) insofar as","= bcA B(α1 · · · αn) for all α1 · · · αn ∈ (2A",")+ such that B ∩ n ⋃ i=1 αi = ∅ . Indeed, has the advantage over ε of qualifying as a model of MSO, which ε does not, under the usual convention that models of predicate logic have non-empty domains.","And even if one were to construct temporal spans from (say, closed intervals of) the real line R as in (Klein, 2009), the string is a fine (enough) representation of R, unbroken and virgin. The in-fluential analysis of tense and aspect in (Reichenbach, 1947) positions the speech s and described event e relative to a reference time r. For instance, in the simple past (e.g. it rained), r coincides with e but precedes s simplePast(e, r, s) := e, r s + e, r s while in the present perfect (e.g. it has rained), r comes after e but coincides with s presentPerfect(e, r, s) := e s, r + e s, r . Factoring out the reference time, the simple past and present perfect become identical ρ {e,r,s} {e,s} (simplePast(e, r, s)) = e s + e s","= ρ{e,r,s} {e,s} (presentPerfect(e, r, s)). e s + e s is a simple example of “the expression of time in natural language” relating “a clause-internal temporal structure to a clauseexternal temporal structure” (Klein, 2009, page 75). The clause-internal structure e and clauseexternal structure s can be far more complex, subject to elaborations from lexical and grammatical aspect. Elaborations in interval temporal logic made in (Dowty, 1979) are formulated in terms of strings in (Fernando, 2013).","The finiteness and discreteness of strings arguably mirrors the bounded granularity of natural language statements (rife with talk of “the next moment”). Boundaries drawn to analyze, for example, telicity become absurd if they separate arbitrarily close pairs of real numbers (as they would, applied to the real line). It is customary to view a model M as an index that the Carnap-Montague intension of a formula φ maps to one of two truth values, indicating whether or not M |= φ. But the construal of a string as an underspecified representation suggests viewing it not only as an index but also as an extension (or denotation) of φ (Fernando, 2011). In this connection, a proposal from (Bach, 1986) is worth recalling — namely, that we associate an event type such as KISSING with a function EXT(KISSING) that maps histories to subparts that are temporal manifestations of KISSING (with input histories as indices, and output manifestations as extensions). Relativizing notions of indices and extensions to a bounded granularity, it is natural to assume at the outset not indices but extensions, which are then enlarged, as required, to more detailed and larger indices. The relation EXT(KISSING) then becomes a relation between strings (contained in ⊒) which a finite-state transducer might compute. For refinements of granularity, we start with an undifferentiated piece (viz. ε or ) rather than a multitude of fully fleshed out possible histories. From ε or , the ingredients we require are a set of auxiliary symbols, and a suitable system RA","B of regular relations, for finite sets A and B ⊆ A of auxiliary symbols, projecting indices over the alphabet 2A to indices over 2B","— e.g., bcA","B or, as in (Fernando,","2013), πA B. 70"]},{"title":"References","paragraphs":["James F. Allen. 1983. Maintaining knowledge about temporal intervals. Communications of the Association for Computing Machinery, 26(11):832–843.","F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi, P. F. Patel-Schneider. 2003. The Description Logic Handbook: Theory, Implementation, Applications. Cambridge University Press.","Franz Baader and Carsten Lutz. 2006. Description logic. In Patrick Blackburn, Johan van Benthem, and Frank Wolter, editors, The Handbook of Modal Logic, pages 757–820. Elsevier.","Emmon Bach. 1986. Natural language metaphysics. In R. Barcan Marcus, G.J.W. Dorn, and P. Weingartner, editors, Logic, Methodology and Philosophy of Science VII, pages 573 – 595. Elsevier.","Kenneth R. Beesley and Lauri Karttunen. 2003. Finite State Morphology. CSLI,Stanford,","David R. Dowty. 1979. Word Meaning and Montague Grammar. Reidel, Dordrecht.","Andrzej Ehrenfeucht and Paul Zeiger. 1976. Complexity measures for regular expressions. J. Comput. Syst. Sci., 12(2):134–146.","Tim Fernando. 2004. A finite-state approach to events in natural language semantics. Journal of Logic and Computation, 14(1):79–92.","Tim Fernando. 2011. Regular relations for temporal propositions. Natural Language Engineering, 17(2):163184.","Tim Fernando. 2012. A finite-state temporal ontology and event-intervals. Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing, pages 80–89, Donostia/San Sebastian (ACL archive).","Tim Fernando. 2013. Segmenting temporal intervals for tense and aspect. 13th Mathematics of Language meeting. Sofia, Bulgaria.","Michael J. Fischer and Richard E. Ladner. 1979. Propositional dynamic logic of regular programs. Journal of Computer and System Sciences, 18:194– 211.","Wouter Gelade and Frank Neven. 2008. Succinctness of the complement and negation of regular expressions. In Symposium on Theoretical Aspects of Computer Science, pages 325–336.","Markus Holzer and Martin Kutrib. 2010. The complexity of regular(-like) expressions. In Developments in Language Theory, pages 16–30. Springer.","Mans Hulden. 2009. Regular expressions and predicate logic in finite-state language processing. In Finite-State Methods and Natural Language Processing, pages 82–97. IOS Press.","Hans Kamp and Uwe Reyle. 1993. From Discourse to Logic. Kluwer.","Wolfgang Klein. 2009. How time is encoded. In The Expression of Time, pages 39–82. Mouton De Gruyter.","Hans Reichenbach. 1947. Elements of Symbolic Logic. MacMillan Company, NY.","Alfred Tarski, Andrzej Mostowski, and Raphael Robinson. 1953. Undecidable Theories. North-Holland.","Wolfgang Thomas. 1997. Languages, automata and logic. In Handbook of Formal Languages: Beyond Words, volume 3, pages 389–455. Springer-Verlag.","Anssi Yli-Jyrä and Kimmo Koskenniemi. 2004. Compiling Contextual Restrictions on Strings into Finite-State Automata. In Proceedings of the Eindhoven FASTAR Days. 71"]}]}