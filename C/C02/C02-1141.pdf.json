{"sections":[{"title":"A complete integrated NLG system using AI and NLU tools Laurence Danlos Lattice U. Paris 7, Case 7003 2, place Jussieu 75251 Paris Cedex 05 France danlos@linguist.jussieu.fr Adil El Ghali Lattice U. Paris 7, Case 7003 2, place Jussieu 75251 Paris Cedex 05 France adil@linguist.jussieu.fr Abstract","paragraphs":["A standard architecture for an NLG system has been defined in (Reiter and Dale, 2000). Their work describes the modularization of an NLG system and the tasks of each module. However, they do not indicate what kind of tools can be used by each module. Nevertheless, we believe that certain tools widely used by the AI or NLU community are appropriate for NLG tasks. This paper presents a complete integrated NLG system which uses a Description logic for the content determination module, Segmented Discourse Representation Theory for the document structuring module and a lexicalized formalism for the tactical component. The NLG system, which takes into account a user model, is illustrated with a generator which produces texts explaining the steps taken by a proof assistant."]},{"title":"1 Introduction","paragraphs":["The standard architecture of an NLG system proposed in (Reiter and Dale, 2000) is represented schematically in Figure 1.1. The tool used by a module and the data structure of its output are not precisely defined. According to Reiter and Dale, they vary from one author to the other. However, we believe that certain tools widely used by the AI or NLU community are appropriate for NLG tasks. Therefore, we reformulate in more specific terms Figure 1.1 as Figure 1.2.","The paper describes the modules of Figure 1.2: Section 3 justifies the use of a description logic for the content determination task and its ouput, a “message”; Section 4 specifies the use of sdrt for the document structuring task Document structuring à la SDRT","Communicative goals Content Determination Document Structuring description logicwith aDetermination Content","Communicative goals Lexicalized Micro−planner SurfaceLexicalized Semantic Dependency tree realizer Micro−planner representation Semantic Document Planner","Figure 1.1 Standard architecture of an NLG system Tactical component SDRS","Figure 1.2 Architecture of an NLG system Document plan message logical form with data structures TextText Surface realizer and its output, a “document plan”; Section 5 exposes briefly the use of a lexicalized formalism in the tactical component. Each section is illustrated with GePhoX, a generator that produces texts which explain the steps taken by PhoX , a proof assistant (Raffalli and Roziere, 2002). GePhoX is presented in Section 2.","As this paper intends to present a complete NLG system, there is no room for explaining each module in detail. We refer the reader to (El Ghali, 2001) for the content determination module, to (Danlos et al., 2001) for the document structuring module and to Danlos (1998; 2000) for the lexicalized tactical component. These goal ∀p, d : N(d ̸= N0 → ∃q, r : N(r < d ∧ p = q ∗ d + r)) 1. intros. 2. elim −4 H well founded.N. 3. intros. 4. elim −1 d −3 a lesseq.case1.N. 5. next. 6. intros ∃ ∧. 7. next −3. 8. instance ?1 N0. 9. instance ?2 a. 10. intro. 11. trivial. 12. local a′","= a - d. 13. elim −1 a′","H3. 14. trivial. 15. elim lesseq.S rsub.N. 16. elim −1 [case] H0. 17. trivial =H1 H5. 18. trivial. 19. lefts H5 ∧ ∃. 20. intros ∧ ∃. 21. next −3. 22. instance ?4 r. 23. instance ?3 S q. 24. rewrite mul.lS.N −r add.associative.N −r H8. 25. intro. 26. trivial. 27. save euclide exists. Table 1: Proof script for Euclidian division modules have been built more or less independently from each other, but with the same underlying idea: adaptation of NLU/AI theories and tools to NLG. They are now integrated in a complete model, which is presented here and illustrated with GePhoX, a generator whose implementation is in progress."]},{"title":"2 GePhoX","paragraphs":["PhoX is an extensible proof assistant based on higher order logic, which has been developped to help mathematicians building proofs and teaching mathematics. Like other proof assistants, PhoX works interactively. The user (a mathematician) first gives the theorem to be proven (a goal). PhoX returns a list of subgoals which should be easier to prove than the initial goal. The user enters a command to guide PhoX in choosing or achieving a subgoal. The proof is thus computed top-down from goals to evidences. The user’s commands form a Proof script. PhoX’s output is a list of successive goals equivalent to a Proof tree.","Both the Proof script and PhoX’s output are difficult to read (even for a mathematician), as the reader can see for himself in Table 1 and Table 2. Hence, the need of an NLG system in order to obtain an easy-to-read version of the proof.","GePhoX is given as input both the Proof script and the Proof tree. It is one of the Here is the goal: goal 1/1 |- /\\p,d:N (d != N0 ->","\\/q,r:N (r < d & p = q * d + r)) End of goals. %PhoX% intros. 1 goal created. New goal is: goal 1/1 H := N p H0 := N d H1 := d != N0","|- \\/q,r:N (r < d & p = q * d + r) End of goals."]},{"title":". . .","paragraphs":["Table 2: Proof tree for Euclidian division main original proposals in our generator (similar generators, such as PROVERB (Huang and Fiedler, 1997), take as input only the Proof tree). It makes it possible for GePhoX to start from an incomplete proof and produce texts during the interactive session. These texts help the mathematician user: before entering a new command in the Proof script, he can read a text reminding himself what he has been doing so far. The Proof script is also useful for identifying the reasoning strategies that have been used (reasoning by contradiction or induction), while it is very hard (if not impossible) to retrieve this information from a Proof tree with its numerous deduction steps.","Another originality of GePhoX is that it takes into account the knowledge of the user who can be either a mathematician using PhoX or a person more or less novice in mathematics. For the same proof, GePhoX can generate several texts according to the user model."]},{"title":"3 Using a descrition logic (DL)","paragraphs":["The knowledge representation system Kl-One (Branchman et al., 1979) was the first DL. It was created to formalize semantic networks and frames (Minsky, 1974). It introduces the notions of TBoxes and ABoxes respectively for terminological and assertional knowledge. Kl-One has been widely used in the NLG community to formalize the domain model. On the other hand, this is not the case for the more recent DLs. Nevertheless, they present at least two advantages compared to Kl-One : 1) for a large variety of DLs, sound and complete algorithms have been developped for main inference problems such as subsumption, concepts satisfiability and consistency (Donini et al., 1996); 2) the relations between instances and classes are well defined for all the constructors, and their mathematical and computational properties have been studied in detail (Horrocks et al., 2000). So we believe that DLs are appropriate for the content determination task as shown in 3.3. Let us first briefly present DLs. 3.1 A brief introduction to DL The three fundamental notions of DLs are individuals (representing objects in the domain), concepts (describing sets of individuals), and roles (representing binary relations between individuals or concepts). A DL is characterized by a set of constructors that allow us to build complex concepts/roles from atomic ones. The set of constructors which seem useful for GePhoX and their syntax are shown in Table 3; examples of concepts and roles with their semantic are shown underneath Table 3. Constructor (abbreviation) Syntax atomic concept A top ⊤ bottom ⊥ conjonction C ∧ D disjonction (U) C ∨ D complement (C) ⌝C univ. quant. ∀R.C exist. quant. (E) ∃R.C numeral restrictions (N ) >n R.C","≤n R.C collection of individuals (O) {a1,. . .,an} atomic role P roles conjonction (R) Q ∧ R inverse role R−1 role composition Q ◦ R Table 3: Syntax of standard constructors Examples of concepts with their semantic Theorem, Variable, {H1}, ∃CHOOSE.User { x / Theorem(x) } : Theorem concept { x / Variable(x) } : Variable concept { H1} : concept constructed by the O constructor on individual H1 { x / ∃ u : User, CHOOSE(u,x) } Examples of roles with their semantic IMPLIES, PROVES { x,y / IMPLIES(x,y) } : x implies y { x,y / PROVES(x,y) } : x proves y","The choice of constructors is domain dependent. Constructors other than those used in GePhoX (e.g. temporal extension) can be used for other domains (e.g. domains with non trivial temporal information), without altering the mathematical and computational properties. 3.2 Domain and user models in DL The Domain model is the set of concepts and roles necessary to express the input of the generator. More formally, let TD be a TBox, such that each input I can be described by means of an ABox AD corresponding to TD. The knowledge base ΣD = (TD, AD) is called knowledge base for the domain and noted dkb. The User model is a knowledge base ΣU = (TU , AU ) such that TU and AU are respectivly subsets of TD and AD. ΣU is noted ukb. Table 4 shows a part of the dkb for GePhoX.","Goal MathObj Subgoal Axiom Hypothese Theorem","Rules well_founded Intro lesseq.case1 Elim add.associative Rewrite Operator Trivial LogicalOper Left Exist","ReasonningStrategy Forall ByInduction LAnd ByContradiction ArithOper . . . Add . . . Multi Table 4: GePhoX Domain model 3.3 Content determination tasks The content determination module performs four tasks, as shown in Figure 2. Translation: The input of the generator (assertional information) is first translated into concepts of the TBox. For that purpose, a correspondence is established between the elements of the input and concepts and roles in the dkb. The O constructor is used to keep information about the individuals occurring in the input. For example, command 2 in Table 1 with individual H is translated into the concept C0 . = ∃EliminationW ell f ounded.Hypothese {H}, and commands 8 to 11 are translated into C1 . = ∃ByInduction {p}. Selection: The selection task consists of choosing the relevant concepts among those constructed in the translation phase with regard to the ukb. For example, if C0 is an unknown concept for the user, a concept C must be looked up in the ukb such as C approximates1","C0. TBoxConcepts Concepts Translation Selection Verification Instanciation Terminological Assertional","Logical Form ABox Input Figure 2: Content Determination Tasks Verification: At this point, the coherence of all the concepts of the selection is verified. For example, if the user tries to reason by induction on a real number, GePhoX tells him that it is not possible. Instanciation: With the information about individuals, which have been kept in the translation phase (with the use of the O constructor), the instanciation task is straightforward. Table 5 shows some instanciated concepts for the Euclidian division.","As is well known, designing knowledge bases (dkb and ukb) and translating the input of the generator into concepts and roles of the DL is a difficult task which has to be fulfilled for every generator. However, with a DL, the selection, verification and instanciation tasks are domain independent: algorithms and their implementation are reusable. Moreover, when using a DL for the content determination task, the “message” is a first order logic formula (a standard representation shared by a large commu-","1","Given two TBoxes T and T ′","with T ⊂ T ′","and a concept C ∈ T − T ′",", C′","∈ T ′","approximates C if C minimally subsumes C′","or C′","minimally subsumes C.",". ∃p1 ∈ Entier named(p1, p) choose(user, p1)",". ∃d1 ∈ EntierNonNul named(d1, d) choose(user, d1)",". ∃f1 ∈ Formula constant(f1, ∃q,r: N (r < d ∧ p = q.d + r))",". prove(user, f1) induction(f1, p1) . . . Table 5: DL-Message for Euclidian division nity) which takes into account the user knowledge and whose coherence has been checked."]},{"title":"4 Using SDRT for document structuring","paragraphs":["In (Danlos et al., 2001) we advocate using sdrt (Segmented Discourse Representation Theory (Asher, 1993; Asher and Lascarides, 1998)) as a discourse framework, since sdrt and drt (Discourse Representation Theory, (Kamp and Reyle, 1993)) are the most popular frameworks for formal and computational semantics. Let us briefly present sdrt. 4.1 A brief introduction to SDRT sdrt, designed first for text understanding, was introduced as an extension of drt in order to account for specific properties of discourse structure. sdrt can be viewed as a super-layer on drt whose expressiveness is enhanced by the use of discourse relations. Thus the drt structures (Discourse Representation Structures or drs) are handled as basic discourse units in sdrt.","drss are ”boxed” first order logic formulae. Formally, a drs is a couple of sets ⟨U,Con⟩. U (the universe) is the set of discourse referents. Con contains the truth conditions representing the meaning of the discourse.","A sdrs is a pair ⟨U,Con⟩, see Figure 3. U is a set of labels of drs or sdrs which can be viewed as “speech act discourse referents” (Asher and Lascarides, 1998). Con is a set of conditions on labels of the form:","• π : K, where π is a label from U and K is a (s)drs","• R(πi, πj), where πi and πj are labels and R a discourse relation. Discourse relations are inferred non-monotonically by means of a defeasible glue logic exploiting lexical and world knowledge. SDRS labels     Max fall    "," "," John","push   ","","Explanation      discourse referents DRS (basic discourse constituents) conditions (content/meaning) discourse relation Figure 3: sdrs for Max fell. John pushed him. 4.2 Building a SDRS Starting from a “message” encoded into a logical form, the document structuring module builds a sdrs. On a first step, the logical form is translated into a drs. In the case of a purely existential formula2",", this amounts to putting all the variables into the universe of the drs and splitting the formula into elementary conjoined conditions.","After this first step, the document structuring task amounts to building a sdrs from a drs and to go on recursively on each embedded (s)drs. This process is schematized below. universe condition","1 condition","2 condition","3 condition","4 condition","5 condition","6 condition","7 −→","π 1 π 2 π","3 π 1 :","universe","1","condition","1","condition","7 π 2 :","universe","2","condition","2","condition","5","π","3 : universe","3 condition","4","R","1(π 1, π","2) → condition","3","R","2(π 2, π","3) → condition","6","Let us first examine the principles governing the splitting of the conditions. All the conditions in the drs have to be expressed in the sdrs. Two cases arise:","• either a condition in the drs appears as a condition in one of the sub-drs; that is the case for condition1 which appears in the sub-drs labelled π1; 2 More complex formulas are not considered here.","• or it is expressed through a discourse relation; that is the case for condition3 with R1(π1, π2) → condition3, which means that R1(π1, π2) must have condition3 among its consequences: no other element is in charge of expressing condition3.","To establish discourse relations, the sdrt conditions are reversed. As an illustration, in sdrt for text understanding, there is the Axiom (1) for Narration. This axiom states that if Narration holds between two sdrss π1 and π2, then the main event (me) of π1 happens before the main event of π2. (1) (Narration(π1, π2) → me(π1) < me(π2))","For text generation, this axiom is reversed as shown below (Roussarie, 2000, p. 154): • If k1 and k2 are drss whose main eventualities are not states, • and if the main event of k1 occurs before the main event of k2, • then Narration(π1, π2) is valid when π1 and π2 respectively label k1 and k2.","As another example, the condition cause(e1, e2) can be expressed through Result(π1, π2) or Explanation(π2, π1) when π1 and π2 label the sub-drss that contain the descriptions of e1 and e2 respectively.","Let us now examine how we determine the universes of sub-drss, i.e. discourse referents, while observing two technical constraints, namely:","• the arguments of any condition in a sub-drs must appear in the universe of this drs;","• the universes of all the sub-drss have to be disjoint. This constraint is the counterpart of the following constraint in understanding: “partial drss introduce new discourse referents” (Asher, 1993, p. 71).","These two constraints are not independent. Assuming that the first constraint is respected, the second one can be respected with the following mechanism: if a variable x already appears in a preceding sub-drs labelled πx, then a new variable y is created in the universe of the current sub-drs labelled πy and the condition y = x is added to the conditions of πy. The discourse referent y will be generated as an anaphora if πx is available to πy (Asher, 1993), otherwise it will be generated as a definite or demonstrative NP.","A document structuring module la sdrt based on the principles we have just exposed can be used for any generator (whose “message” is first order logic formula). The algorithm and the rules establish discourse relations (obtained by reversing the rules in NLU) are generic. See below an example of sdrs in GePhoX, the sdrs built from Table 5. π 3π","4 π 3 : π 1π","2 π 1 : x u e","1 user(u) entier(x) named(x,p) choose(e","1,u,x) π 2 : y v e","2 entier-non-nul(y) named(y, d) choose(e","2,v,y) v = u","Parallel(π 1,π","2) π 4 : x 1 f w e","3 formula(f) constant(f,∃q,r:N . . . ) prove(e","3,w,f) induction(e","3,x","1) w = u x 1 = x","Narration(π 3,π","4) Table 6: sdrs for Euclidian division"]},{"title":"5 Using a lexicalized grammar for the tactical component","paragraphs":["Lexicalized grammars are commonly used in NLU and also in NLG (Stede, 1996). In Danlos (1998; 2000) we propose a lexicalized formalism, called g-tag, for the tactical component of an NLG system. It is modularized into a microplanner which produces a semantic dependency tree and a surface realizer which produces the text (see Figure 1.2).","The surface realizer is designed to use the syntactic and lexical information of a lexicalized tag grammar. The tag grammar is extended to handle multi-sentential texts and not only isolated sentences.","The microplanner is based on a lexicalized conceptual-semantic interface. This interface is made up of concepts; each concept is associated with a lexical database. In our model, a concept is either a term in the TBox or a discourse relation. A lexical database for a given concept records the lexemes lexicalizing it with their argument structure, and the mappings between the conceptual and semantic arguments. The process of generating a semantic dependency tree from a sdrs ⟨U,Con⟩ is recursive:","- An element πi in U is generated as a clause if πi labels a drs and recursively as a text (possibly a complex sentence) if πi labels a sdrs.","- A condition R(πi, πj) in Con is generated as a text “Si. Cue Sj.” or as a complex sentence “Si Cue Sj.”, where Si generates πi, Sj πj, and Cue is a cue phrase which is encoded in the lexical database associated with R (Cue may be empty).","- A condition π : K in Con where K is a drs ⟨U,Con⟩ is generated as a clause according to the following constraints (which are the counterparts of constraints in understanding):","• A discourse referent in U is generated as an NP or a tensed verb.","• Conditions guide lexical choices. Conditions such as x = John correspond to proper nouns. Equality conditions between discourse referents (e.g. x = y) give rise to (pronominal or nominal) anaphora. The other conditions, e.g. prove(e1, x, y), are lexicalized through the lexical data base associated with the concept (prove).","The surface realizer, based on a tag grammar, is a set of lexical data bases. A data base for a given lexical entry encodes the syntactic structures realizing it with their syntactic arguments. With such a tag grammar and a morphological module, the text is computed in a de-terministic way from the semantic dependency tree."]},{"title":"6 Conclusion","paragraphs":["Since NLG is a subfield of NLP, which is itself a subfield of AI, it seems to be a good idea to reuse tools developped by the NLP or AI community. We have shown in this paper how to integrate DL, sdrt, and a lexicalized grammar into an NLG system, while following the standard pipelined architecture3",". 3","Some authors (de Smedt et al., 1996) have made justified criticisms of the pipelined architecture. However, we decided to keep it for the time being. Theorem. ∀p,d:IN (d ̸= 0 → ∃q,r:IN (r < d ∧ p = q.d + r)) Proof. Let us choose p, d two natural numbers with d ̸= 0. By induction on p we prove ∃q,r:IN (r < d ∧ p = q.d + r). Let take a a strictly positive natural. We assume ∀b:IN (b < a → ∃q,r:IN (r < d ∧ b = q.d + r)) and we must prove ∃q,r:IN (r < d ∧ a = q.d + r). We distinguish two cases: a < d and d ≤ a. In the first case, we choose q = 0 and r = a. In the second case, we take a′","= a − d. Using the induction hypothesis on a′",", we find two naturals q, r such that r < d and a′","= q.d + r. We take S q and r as quotient and remaining for the division of a. We must prove a = S q.d + r which is immediate. Table 7: A Text of proof for Euclidian division","GePhoX illustrates the applicabilty of our system. It is currently being implemented in Java. The development of the document planner of GePhoX is work in progress. The goal is to interface this module with CLEF (Meunier and Reyes, 1999), an implementation of g-tag. We intend to produce a text as shown in Table 7."]},{"title":"References","paragraphs":["N. Asher and A. Lascarides. 1998. The semantics and pragmatics of presupposition. Journal of Semantics, 15(3):239–300.","N. Asher. 1993. Reference to Abstract Objects in Discourse. Kluwer, Dordrecht.","R. Branchman, R. Bobrow, P. Cohen, J. Klovstad, B. Webber, and W. Woods. 1979. Research in natural language understanding. Technical Report 4274, Bolt. Beranek and Newman, Cambridge MA.","L. Danlos, B. Gaiffe, and L. Roussarie. 2001. Document structring à la sdrt. In ACL’2001 Toulouse Proceeding.","L. Danlos. 1998. G-TAG : un formalisme lexicalisé pour la génération de textes inspiré de tag. Revue T.A.L., 39(2):7–33.","L. Danlos. 2000. G-TAG: A lexicalized formalism for text generation inspired by Tree Adjoining Grammar. In A. Abeillé and O. Rambow, editors, Tree Adjoining Grammars: for-malisms, linguistics analysis and processing, pages 343–370. CSLI Publications, Stanford.","K. de Smedt, H. Horacek, and M. Zock. 1996. Architectures for natural language generation: Problems and perspectives. In G. Adorni and M. Zock, editors, Trends in NLG. Proceedings of the 4th European Workshop, EWNLG’93, Pisa. Springer-Verlag.","F. Donini, M. Lenzerini, D. Nardi, and A. Schaerf. 1996. Reasoning in description logics. In G. Brewka, editor, Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and Information. CLSI Publications.","A. El Ghali. 2001. Une logique de description pour le module quoi-dire-? DEA de linguistique informatique, Université Paris 7.","I. Horrocks, U. Sattler, and S. Tobies. 2000. Practical reasoning for very expressive description logics. Logic Journal of the IGPL, 8(3):239–264.","X. Huang and A. Fiedler. 1997. Proof verbalization as an application of NLG. In IJCAI (2), pages 965–972.","H. Kamp and U. Reyle. 1993. From Discourse to Logic. Kluwer Academic Publishers, Dordrecht, The Netherlands.","F. Meunier and R. Reyes. 1999. La plate forme de dveloppement de gnrateurs de textes CLEF. In Actes du 2e Colloque Francophone sur la Gnation Automatique de Textes, GAT’99, Grenoble.","M. Minsky. 1974. A framework for representing knowledge. MIT-AI Laboratory Memo 306.","C. Raffalli and P. Roziere, 2002. The PhoX Proof checker documentation. LAMA, Université de Savoie / Université Paris 7.","E. Reiter and R. Dale. 2000. Building Natural Language Generation Systems. Cambridge University Press.","L. Roussarie. 2000. Un modèle théorique d’inférences de structures sémantiques et discursives dans le cadre de la génération automatique de textes. Thèse de doctorat en linguistique, Université Paris 7.","M. Stede. 1996. Lexical paraphrases in multilingual sentences generation. Machine Translation, 11."]}]}