{"sections":[{"title":"Signatures, Typed Feature Structures and RDFS Matthias Denecke  ","paragraphs":["Interactive Systems Laboratories","Carnegie Mellon University Pittsburgh, PA, 15213","U.S.A. denecke@cs.cmu.edu","Abstract In this paper, we examine how attribute logic signatures and typed feature structures can be serialized using emerging semantic web standards RDF and RDFS. Inversely, we also consider to which degree the logic of typed feature structure is capable of representing and drawing inferences over RDF and RDFS documents."]},{"title":"1. Introduction","paragraphs":["The representation of task related concepts is part of many natural language processing systems. Recently, there have been several projects involving several sites and project partners each of which develops a component that needs to receive data from other components, process it and resend the output to a subsequent component. Consequently, there is the issue to agree upon, to specify and to represent the concepts the system can understand. This can be seen as the vocabulary of the language in which components communicate with each other or in which knowledge sources are serialized. Note that this issue is orthogonal to the issue of deciding in which format the concepts should be exchanged. This can be seen as the syntax of the language in which components interact. For example, the fact that the exchange format has been decided to be XML does not describe the content of the exchanged messages.","For this reason, implemented systems often incorporate, or have access to, an ontology that represents the understood concepts and the relationships between them. This is particular prevalent in machine translation systems that employ an interlingua representation (see for example (Woszczyna et al., 2000)) and task oriented spoken dialogue systems.","In several systems, typed feature structures (Carpenter, 1992) have been shown to be popular representations. Originally developed with applications in grammar development in mind, the fact that the atoms of typed feature structures are partially ordered in a type hierarchy make this particular formalism appealing for task oriented natural language processing. In addition, efficientand simple implementations of subsumption and unificationalgorithms are available.","On the other hand, emerging W3C standards are concerned with semantic annotations of web resources. These efforts include the Resource Description Framework (RDFMS, 1999) and its Schema language RDFS (RDF Schema, 2000), and, building on top of RDFS, the Darpa Agent Markup Language (DAML for short) and and the Ontology Inference Layer (OIL for short). Both efforts recently joined forces and produced the DAML+OIL language.","In this paper, we look at how the logics of typed feature structures and the RDF and RDFS semantic web standards complement each other. The paper is organized as follows. In section 2, we give an overview of RDFS. In section 3, we give an overview of those aspects of typed feature structures that are relevant to our discussion. In section 4, we compare the two representations. In section 5, we preent mappings from signatures to RDFS documents and from typed feature structures to RDF documents, respectively. In section 6, we provide inverse mappings from particular RDFS documents to signatures and form particular RDF documents to typed feature structures, respectively. In section 7, we discuss the application of the techniques here presented to task oriented spoken language processing."]},{"title":"2.","paragraphs":["RDF"]},{"title":"und","paragraphs":["RDF"]},{"title":"Schema","paragraphs":["RDF defines a simple data model for describing properties of and interrelationships between resources. It does not, however, provide any typing mechanism or content restriction. This functionality is provided by RDF Schema. A schema defines the kind of resources that are being described, and imposes semantic restrictions on the relationships between the described resources.","The RDF schema (RDFS for short) provides thus a basic type model to be used in RDF data models. 2.1. Classes","RDFS allows for the introduction of concepts by means of the rdfs:class tag. For example, <rdfs:Class rdf:ID=\"motorvehicle\"/> declares a class motorvehicle. It is possible to create subclasses using the rdfs:subClassOf tag, as in sportscar pickuptruck semitruckminivan passengervehicle utilityvehicle motorvehicle Figure 1: A class hierarchy.","<rdfs:Class rdf:ID=\"utilityvehicle\">","<rdfs:subClassOf","rdf:resource=\"motorvehicle\">","</rdfs:Class>","<rdfs:Class rdf:ID=\"passengervehicle\">","<rdfs:subClassOf","rdf:resource=\"motorvehicle\">","</rdfs:Class> Multiple inheritance is equally possible:","<rdfs:Class rdf:ID=\"minivan\"> <rdfs:subClassOf","rdf:resource=\"utilityvehicle\"> <rdfs:subClassOf","rdf:resource=\"passengervehicle\">","</rdfs:Class>","Instances of classes are RDF descriptions. Their class membership is indicated by means of the rdf:type tag. <rdf:Description rdf:ID=\"MyCar\">","<rdf:type rdf:resource=\"#sportsvehicle\"> </rdf:Description> Note that a description may have multiple types as in","<rdf:Description rdf:ID=\"OldVan\">","<rdf:type rdf:resource=\"utilityvehicle\">","<rdf:type rdf:resource=\"passengervehicle\">","</rdf:Description>","Figure 1 shows the class hierarchy used in the examples in this paper.","It should be noted that the relationship between classes induced by the rdfs:subClassOf tags may contain circular references (RDFMT, 2002). This is a recent change from the previous requirement disallowing circular references. 2.2. Properties","Properties are resources that express relationships between resources. The types of resources a property relates can be restricted with the rdfs:domain and rdfs:range tags. For example, the declaration","<rdf:Property rdf:ID=\"requiresLicense\">","<rdfs:domain rdf:resource=\"MotorVehicle\">","<rdfs:range rdf:resource=\"License\">","</rdf:Property> allows for the expression of relationships between motor vehicles and the licenses necessary to operate them.","The rdfs:subPropertyOf tag represents the relationship corresponding to the rdf:subClassOf relationship between classes. For example, sportscar pickuptruck passengerandutilityvehicle passengervehicle utilityvehicle motorvehicle semitruckminivan Figure 2: A type hierarchy.","<rdf:Property rdf:ID=\"requiresSpecialLicense\">","<rdfs:domain rdf:resource=\"SemiTruck\">","<rdfs:range rdf:resource=\"SpecialLicense\">","</rdf:Property> allows for the expression of relationships between semi trucks and the special kind of licenses required for them.","As a note, it is possible to have multiple domain and range constraints for the same property, in which case they are interpreted conjunctively (RDFMT, 2002), i.e. the properties need to set in relationship objects that are members of all classes declared in the domain and range constraints."]},{"title":"3. Signatures and Typed Feature Structures","paragraphs":["Carpenter (1992) (LTFS henceforth) proposes to represent concepts in a so-called type hierarchy where the underlying partial order is a meet-semilattice, i.e. if any pair of types has upper bounds there is a unique upper bound.","3.1. Ordering of the Types Type hierarchies ","are required to be meet semi lattices. This implies that if any set of types ","has an upper bound, this upper bound is uniquely determined. A consequence of this and the fact that unificationof typed feature structures is definedin terms of upper bounds makes unificationof typed feature structures unique. Throughout the paper, we will use the type hierarchy shown in figure2 as an example. 3.2. Appropriateness Conditions","Appropriateness conditions restrict feature structures in constraining both the features that are appropriate for a given type as well as the values features may take. Definition3..1 (Appropriateness Specifications) An appropriateness specification over the type hierarchy","and a set of features ","is a partial function","   that meets the following conditions","(i) Feature Introduction for every feature  , there is a most general type","    such that"," ","  "," is defined,and","(ii) Upward Closure/Right Monotonicity if"," "," is defined and"," ","",", then"," ","is also defined and such that  "," ","  A type hierarchy  , a set of features  and an appropriateness condition  over  and  ","is called a signature (Penn, 2001).","An example for appropriateness conditions is given by","","","","   ","","","","","","",""," ","","  ","","","","","","","   ","","","",""," ","   ","",""," 3.3. Typed Feature Structures","Typed feature structures are labelled rooted acyclic graphs in which each node is annotated with a type symbol   and each arc is annotated with a feature symbol"," "," ",". Furthermore, for each node there may be at most","one arc that is annotated with a given feature",". Figure 3","shows three typed feature structures. REQUIREDLICENSE licensemotorvehicle passengervehicle COLOR REQUIREDLICENSE privatelicense green semitruck red COLOR (a) (b) (c) Figure 3: Three typed feature structures in graph notation. More formally:","Definition3..2 (Typed Feature Structure) A feature","structure","","","   ","","","",""," consists of a set of nodes  with a distinguished root node     , a total type function  that assigns each node  its type     and a partial feature function  definingthe structure of the graph in that   ","  gives the root node of the structure if feature","is applied to  .","There is a structural algorithm that decides if one fea-","ture structure","is at least as informative as",", or in other","words, if subsumes",". Definition3..3 (Subsumption) A feature structure","subsumes another feature structure","iff there is a homomorphism ","from the nodes in to the node in","such that 1.    ","     (the correspondent of the root node in","is","the root node in","), 2. if   ",""," is definedthen        "," is also definedand such that","    ",""," ","       "," ( ","is a homomorphism w.r.t. the graph that underlies the feature structure), 3. if     ","  then           (if   is the correspondent of some node  then the type of   is at least as informative as the type of  . Informally, conditions (i) and (ii) ensure that the underlying graph of","is a subgraph of the underlying graph of while condition (iii) ensures that the type information in is at least as specificas the type information in",".","In figure3, feature structure (a) subsumes feature structure (b) but not feature structure (c)."]},{"title":"4. Comparison between RDF Schema and Type Hierarchies 4.1. Classes and Types","paragraphs":["Both LTFS and RDFS provide representations of relations between concepts. Since the requirements on a type hierarchy are stricter than those on a class hierarchy in RDFS, type hierarchies can easily represented in RDFS but not any set of classes in RDFS is a type hierarchy. We will see below how in certain cases a set of classes can be converted in order to satisfy the conditions on type hierarchies. The contentious conditions include the fact that the rdfs:subClassOf relationship is not necessarily a meet semilattice; indeed due to circular references it might not even be a partial order. 4.2. Appropriateness Specificationsand Properties","It is impossible in LTFS to express inheritance relationships between features. In other words, a signature exhibits a ”flat” partial order between features where any two different features","","and","","are incomparable. On the other hand, there is no equivalent to the increasing specificity of the appropriateness constraints (see definition3..1 (ii)) as domain and range constraints are interpreted conjunctively1 (RDFMT, 2002). This means that the naive translation of the appropriateness specification3.2. into","<rdf:Property rdf:ID=\"requiresLicense\">","<rdfs:domain rdf:resource=\"semitruck\">","<rdfs:range rdf:resource=\"speciallicense\">","</rdf:Property>","<rdf:Property rdf:ID=\"requiresLicense\">","<rdfs:domain rdf:resource=\"motorvehicle\">","<rdfs:range rdf:resource=\"license\">","</rdf:Property> is equivalent to","<rdf:Property rdf:ID=\"requiresLicense\">","<rdfs:domain rdf:resource=\"semitruck\">","<rdfs:range rdf:resource=\"speciallicense\">","</rdf:Property> which, in turn, does not correspond to the appropriateness specification. 4.3. Instantiations of Classes","As noted above, RDF descriptons can be instances of two or more classes. There is no possibility to represent equivalent information in LTFS. The workaround described 1 Note that in an earlier draft (RDF Schema, 2000), the inter-","pretation of multiple range restrictions was disjunctively in more detail below consists of adding additional types as needed if descriptions are instances of multiple classes.","Furthermore, due to the fact that instantiations of RDFS classes can have multiple types, together with the fact that the language does not contain negation, there are no inconsistent RDF descriptions. In LTFS, however, the process of unification assigns multiple types to nodes. If there is no upper bound for these types, the description is said to be inconsistent, and the unificationfails."]},{"title":"5. Representing Signatures in","paragraphs":["RDFS After having compared the differences and similarities between signatures and RDFS in the last section, we proceed to definea mapping ","from signatures to RDFS document fragments and from typed feature structures to RDF document fragments.","5.1. Mapping Types The mapping  of a type hierarchy  to an RDFS class hierarchy is straightforward, as  is a","partial order. The distinguished type is mapped onto <rdfs:Class rdf:ID=\"bot\"/> All other types  with direct super types","","  ",""," are mapped onto","<rdfs:Class rdf:ID=\"","\"/>","<rdfs:subClassOf rdf:resource=\"#","\"/> .. . .. .","<rdfs:subClassOf rdf:resource=\"#","\"/>","</rdfs:Class> 5.2. Mapping Appropriateness Conditions","The mapping of appropriateness conditions takes advantage of the trick described in the previous section. In order to avoid redundancy in the specification, we consider the appropriateness function  for those places","where it changes.","In the following, an equation of the form  ",""," for types   ","and a feature","is called an appropriateness constraint. An appropriateness constraint is called redundant if it can be inferred form another appropriateness constraint. For example, if","  "," and"," "," "," , then","   "," ","","is redundant. A non-redundant appropriateness constraint is called informative. The name of an appropriateness constraint"," "," "," is","  2 . An appropriateness constraint"," "," "," subsumes another appropriateness constraint","    ","  ","","iff "," and","  "," and","  ","",".","As an example, we consider again the ap-","propriateness specification 3.2.. The constraint","","","","","    ","","","","","","","",""," ","  ","","is redundant as it can be inferred from","","","","","","   ","","","","",""," ","  "," , together with the knowledge that","2","For expository reasons, we assume that the character ’ ’ does not appear in the names of the classes and properties. If it does, some more elaborate name mangling mechanisms would have to take place","","","","","","","  ","","","","","","","",". On the other hand,","","","","","   ","","","","","","","   ","",""," is informative. Given a signature, we construct property constraints for all informative appropriateness constraints induced by",". Let"," "," ","","be an informative appropriateness constraint. In order to correctly construct RDFS properties, we need to distinguish between the ”roots” in the constraint hierarchy (the constraints covered by the feature introduction condition in definition3..1) and those that specialize other constraints (the constraints covered by the Upward Closure condition in definition3..1). This can be determined by looking at  : if","","  ","","",", then the first","case holds, otherwise the second case holds.","Let first","","  ",""," . The generated RDFS fragment is then given by","<rdfs:Property rdf:ID=\" ","","\">","<rdfs:domain rdf:resource=\"","\"/>","<rdfs:range rdf:resource=\"","\"/>","</rdfs:Property>","In the other case, the appropriateness constraint special-","izes one or more less specific appropriateness constraints",""," "," ","  . In this case, we generate the following RDFS code.","<rdfs:Property rdf:ID=\"","  \">","<rdfs:domain rdf:resource=\"","\"/>","<rdfs:range rdf:resource=\"","\"/>","<rdfs:subPropertyOf rdf:resource=\"#","","","\">","...","...","<rdfs:subPropertyOf rdf:resource=\"#","","","\">","</rdfs:Property>","The appropriateness conditions above generate the following document fragment.","<rdfs:Property","rdf:ID=\"reqLicense motorvehicle license\">","<rdfs:domain rdf:resource=\"#motorvehicle\"/>","<rdfs:range rdf:resource=\"#license\"/>","</rdfs:Property>","<rdfs:Property","rdf:ID=\"reqLicense semitruck trucklicense\">","<rdfs:domain rdf:resource=\"#semitruck\"/>","<rdfs:range rdf:resource=\"#trucklicense\"/>","<rdfs:subPropertyOf","rdf:resource=\"#reqLicense motorvehicle license\">","</rdfs:Property>","5.3. Mapping Feature Structures","In mapping feature structures to RDF documents, we","need to make sure to capture all information from the fea-","ture structures in RDF. We propose to create a new blank","node for each node in the typed feature structure, and to","link the nodes through properties. More specifically, if","","  ","","","","","","",""," then for each node    with","","     we generate the following RDF fragment.","<rdf:Description rdf:ID=\"","\">","<rdf:type rdf:resource=\"t\"/>","</rdf:Description> Here   ",""," is a name uniquely generated for each node   ",". In addition, if   ",""," is definedin ","for any feature",", then we need to add that information to the description as well. This is done by mapping features to properties. The name of the property is chosen to be the most specificone that subsumes the the property given by      and      .","In this case, the description created for that node becomes","<rdf:Description rdf:ID=\"","","","\">","<rdf:type rdf:resource=\"t\"/>","<","","    ","","rdf:resource=\"#","","\"/>",".","..",".","..","<","","","","  ","","rdf:resource=\"#","","\"/>","</rdf:Description>","For example, the feature structure shown in figure3 (b)","shown here in attribute value matrix notation,",""," passengervehicle REQUIREDLICENSE privatelicense COLOR green   is mapped to the document fragment","<rdf:Description rdf:ID=\"node 3\">","<rdf:type rdf:resource=\"passengervehicle\"/>","<requiredLicense passvehicle prlicense","rdf:resource=\"#node 5\"/>","<color rdf:resource=\"#node 4\"/>","</rdf:Description>","<rdf:Description rdf:ID=\"node 5\">","<rdf:type rdf:resource=\"privateLicense\"/>","</rdf:Description>","<rdf:Description rdf:ID=\"node 4\">","<rdf:type rdf:resource=\"green\"/>","</rdf:Description> The graph representing the feature structure is shown in figure 4.","Note that the RDF graph constructed that way is a plain graph in RDFS parlance, meaning that it does not contain literals. On the other hand, since the nodes of feature structures are mapped to blank nodes in RDF descriptions, the graph is not ground. 5.4. Properties of the mapping","Before we discuss how subsumption is preserved through the mapping, we need to introduce the concept of simple entailment and RDFS entailment. In the process, we will refer to RDFS closure rules which are defined in (RDFMT, 2002). According to (RDFMT, 2002), one graph  simply entails another graph   if every interpretation that satisfiesevery member of  also satisfiesevery member of ","",". In this section, we will use the graph notation of document fragments. Furthermore, one graph RDFS entails another if the closure of the RDFS graph simple entails the closure of the other graph. The closure operation has the function of pulling in all the schema information. For example, the closure of the graph shown in figure4 will add the nodes and the arc","","","","","","","","","","",""," passenger Vehicle node3 node4 node5 reqLicense_passvehicle_prlicense color rdf:type rdf:type rdf:type green prlicense Figure 4: A feature structure in graph notation.","since the schema contains","","","","","     ","","","","","","","",""," and the graph representing the feature structure contains","","","","","","  ","","","","","",""," In addition, the closure will also generate the transitive closure of the rdfs:subClassOf and rdfs:subPropertyOf relationships.","The mapping from typed feature structures to RDF documents has the desirable property that ","","implies that","","  is rdfs-entailed by"," ","  . This can be seen as follows. ","","implies the existence of the homomorphism","with the properties given in definition 3..3. Then, for","each pair of nodes  ","       with     ","  we know by assumption that    ","    ","","",". The generation of the","RDF schema from the signature using the proces described","above ensures that the graph contains a chain of subclass","relationships","           ","","   ","","","","    ...","...","   ","","   ","","",""," ","      ","The closure rule RDFS 8 adds the statement","         ","","   ","","",""," ","        ","(1)","The RDF document fragments representing","and","con-","tain the triples","      ","","","","","","","","","","  ","(2)","and       ","","","  ","","","      ","(3)","respectively. Closure rule RDFS 9, when applied to 1 and 3","will add the statement ","","     ","","","","","","","","","","  ","(4) to the document fragment representing",". This is due to the fact that the sublass relationship in (3) holds.","Similar closure rules exist for properties that inherit from superproperties. To summarize, the closure rules will add all weaker class membership and property membership statements to the graph. Since by assumption, the class and property membership statements of","    are weaker than those of"," ","  the closure of"," ","  is a superset of the closure of","  ","","modulo node IDs. This is sufficient to","prove simple entailment.","As an example, the feature structure shown in figure3","(a) shown here in attribute value matrix notation,  motorvehicle REQUIREDLICENSE license is mapped to the document fragment","","","","","","   ","","","","","","","","","","","","","","  ","","","","","","","","","","","","","   ","","","",""," (5) The document fragment generated from the feature structure (b), shown above, shown in graph notation:","","","","","","   ","","","","","","","","","","","","","","","","   ","","","","","","","","","","","   ","","","","","","","","","   ","","","","","","","","","","","     ","",""," (6)","The closure rules RDFS 6 and RDFS 9 (see (RDFMT, 2002)) add the following triples to the graph, respectively:","","","","","","","","","  ","","","","","","","","","","","","","","","   ","","","","","","","","","","","   ","","","",""," (7)","If the triples in 6 and 7 are true, then the triples in 5 are also true, choosing the assignment where     and     , as well as   "," and     are assigned the same resource."]},{"title":"6. Interpreting","paragraphs":["RDFS"]},{"title":"as Signatures","paragraphs":["The previous section addressed the issue of generating an RDFS document that truthfully represents a signature. In this section, we consider the inverse problem, that is, to interpret an RDFS document as a signature. The requirements on signatures are stricter than those on RDF schemas. Consequently, and as also can be deduced from the discussion in the last section, there is no hope that all RDFS documents can be interpreted as signatures: in the last section, we restricted degrees of freedom in designing the property constraints to express appropriateness conditions; if, in the inverse conversion, the RDFS document does not meet these restrictions, there is no hope that it can be expressed as a signature. There are, however, some requirements on signatures that, if not satisfiedin the RDF schema, can be mechanically restored. This includes the meet semilatticehood condition. 6.1. Mapping Classes","The difficultyin interpreting an RDFS class hierarchy as type hierarchy ","is due to the fact that the latter is required to be a meet semi lattice while the former is only guaranteed to be a partial order. This implies in particular, that if a set of classes has an upper bound, there need not be a uniquely determined least upper bound. The solution to this problem is to apply the meet semilattice completion algorithm (Penn, 2001) to the class hierarchy. This algorithm inserts additional dummy classes where needed in order to fulfil the meet semilatticehood condition. In addition, we also add a distinguished element","to the resulting order, if there is no least element in the class hierarchy.","For example, the meet semilattice completion algorithm, if applied to the class hierarchy shown in figure 1 will generate the meet semilattice shown in figure2.","It is legal in RDFS to define circular inheritance relationships, i.e. relationships of the form a ","rdfs:subClassOf a ... a  rdfs:subClassOf aa  . The intended meaning is to state that the classes a  to a ","are equivalent. We can transform an RDF schema specificationwith circular inheritance relationships into one without circular inheritance relationships by factorization, whereby two classes    are equivalent  "," iff a rdfs:subClassOf  b and b rdfs:subClassOf ","a. This needs to be done before the MSL algorithm is applied. 6.2. Mapping Properties","Multiple domain and range restrictions are dealt with as follows. Let","","","","","","","","","","","be the domain (range) restrictions of any given property. If there is a class  that is a direct subclass of","","","","","","","","","","","but that is not a direct subclass of any other class, then replace the multiple domain (range) restrictions with that class. If there is no such class add the declaration","<rdfs:Class rdf:ID=\"","\">","<rdfs:subClassOf rdf:resource=\"","","\">","... ...","<rdfs:subClassOf rdf:resource=\"","","\">","</rdfs:Class> and replace any occurrence of rdfs:subClassOf rdf:resource=\"   \" in other class definitions with","rdfs:subClassOf rdf:resource=\" ","\".","As mentioned above, signatures do not allow to represent feature hierarchies. However, since we can encode appropriateness conditions in property hierarchies, we should inversely be able to interpret property hierarchies as appropriateness conditions. This, of course, can only succeed if the property hierarchy in question satisfies the conditions of the appropriateness conditions."]},{"title":"7. Applications to Task-Oriented Natural Language Processing","paragraphs":["The mappings from signatures and typed feature structures to RDFS and RDF document fragments, respectively, demonstrate that RDF(S) can be used as a convenient (and standardized) way to serialize signatures and typed feature structures. Denecke and Waibel (1997), Johnston (1998) and Denecke and .Yang (2000) showed how signatures can be used as domain models for spoken dialogue systems, as the basis for generating efficientclarificationquestions and for fusion of multimodal input streams in multimodal dialogue systems. Denecke and Waibel (1999) demonstrate how the domain model of a spoken dialogue system can be assembled from several smaller ontologies. This technique is also supported by RDFS documents, their URIs serving at the same time as namespaces.","Inversely, as the limited mappings from RDF and RDFS documents to signatures and typed feature structures suggest, LTFS can be used to represent and reason with certain RDF(S) documents."]},{"title":"8. Conclusion","paragraphs":["In this paper, we presented algorithms to convert signatures for typed feature structures and typed feature structures to RDFS and RDF document fragments, respectively. The resulting document fragments represent all the information encoded in the original signatures and feature structures. We also presented algorithms that can convert some RDFS and RDF document fragments to signatures and typed feature structures, respectively. Further-more, we gave examples of RDFS and RDF document fragments that cannot be converted to signatures or typed feature structures without loss of information. In short, the result of the paper is that RDFS documents without the rdfs:subPropertyOf tag can be converted to signatures and RDF documents in which there are no two arcs with the same label leaving any node can be converted to a typed feature structure.","Applications of the algorithms include the exchange of ontologies and semantic representation between components in natural language processing applications.","Future work includes extension of the algorithms presented here to treat containers and integral datatypes correctly."]},{"title":"9. References","paragraphs":["B. Carpenter. 1992. The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science, Cambridge University Press.","M. Denecke and A.H. Waibel. 1997. Dialogue Strategies Guiding Users to their Communicative Goals. In Proceedings of Eurospeech, Rhodos, Greece. Available at http://www.is.cs.cmu.edu.","M. Denecke and A. H. Waibel. 1999. Integrating Knowledge Sources for a Task-Oriented Dialogue System. In Workshop on Knowledge and Reasoning in Practical Dialogue Systems, Stockholm, Sweden. Available at http://www.is.cs.cmu.edu.","M. Denecke and J .Yang. 2000. Partial Information in Multimodal Dialogue Systems. In Proceedings of the International Conference on Multimodal Interfaces. Available at http://www.is.cs.cmu.edu.","M. Johnston. 1998. Unification-Based Multimodal Parsing. In Proceedings of the 17th International Conference on Computational Linguistics and the 36th An-nual Meeting of the Association for Computational Linguistics (COLING-ACL 98), Montreal, Canada. Association for Computational Linguistics Press. Available at http://www.cse.ogi.edu.","G. Penn. 2001. Tractability and Structural Closures in Attribute Logic Signatures. In Proceedings of the 39th An-nual Meeting of the Association for Computational Linguistics (ACL 2001), Toulouse, France.","RDF Schema. 2000. Resource description framework schema specification. Technical report.","RDFMS. 1999. Resource description framework model and syntax specification.","RDFMT. 2002. RDF model theory. Technical report, W3C.","M. Woszczyna, M. Broadhead, D. Gates, M. Gavalda, A. Lavie, L. Levin, and A. Waibel. 2000. Evaluation of a practical interlingua for task-dependent dialogue. In Proceedings of the AMTA SIG-IL Third Workshop on Interlinguas and Interlingua Approaches, Seattle, Washington. Available at http://www.is.cs.cmu.edu."]}]}